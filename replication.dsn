
include "../../dsn.dsn"

namespace cpp dsn.replication

struct ReplicationMsgHeader
{
    1:i64 id;
}

struct meta_msg_header
{
    1:i32 rpc_tag;
}

struct meta_response_header
{
    1:i32 err;
    2:dsn.end_point primary_address;
}

struct global_partition_id
{
    1:i32  app_id = -1;
    2:i32  pidx = -1;
}

struct mutation_header
{
    1:global_partition_id gpid;
    2:i64             ballot;
    3:i64             decree;
    4:i64             log_offset;
    5:i64             last_committed_decree;
}

struct mutation_data
{
    1:mutation_header header;
    2:list<dsn.blob>  updates;
}

enum partition_status
{
    PS_INACTIVE,
    PS_ERROR,
    PS_PRIMARY,
    PS_SECONDARY,
    PS_POTENTIAL_SECONDARY,
    PS_INVALID,
}

struct partition_configuration
{
    1:string                 app_type;
    2:global_partition_id    gpid;
    3:i64                    ballot;
    4:i32                    max_replica_count;
    5:dsn.end_point          primary;
    6:list<dsn.end_point>    secondaries;
    7:list<dsn.end_point>    drop_outs;
    8:i64                    last_committed_decree;
}

struct replica_configuration
{
    1:global_partition_id gpid;
    2:i64                 ballot;
    3:dsn.end_point       primary;
    4:partition_status    status = partition_status.PS_INACTIVE;
}

enum read_semantic_t
{
    ReadLastUpdate,
    ReadOutdated,
    ReadSnapshot
}

struct client_read_request
{
    1:global_partition_id gpid;
    2:read_semantic_t     semantic = read_semantic_t.ReadLastUpdate;
    3:i64                 version_decree = -1;
}

struct client_response
{
    1:i32 err = 0;
    2:i32 pending_request_count = 0;
    3:i64 last_committed_decree = 0;
}

struct PrepareAck
{
    1:global_partition_id gpid;
    2:i32                 err;
    3:i64                 ballot;
    4:i64                 decree;
    5:i64                 last_committed_decree_in_app;
    6:i64                 last_committed_decree_in_prepare_list;
}

struct learn_state
{
    1:dsn.blob      meta;
    2:list<string>  files;
}

enum learner_status
{
    LearningWithoutPrepare,
    LearningWithPrepare,
    LearningSucceeded,
    LearningFailed,
    Learning_INVALID
}

struct learn_request
{
    1:global_partition_id gpid;
    2:dsn.end_point       learner;
    3:i64                 signature;
    4:i64                 last_committed_decree_in_app;
    5:i64                 last_committed_decree_in_prepare_list;
    6:dsn.blob            app_specific_learn_request;
}

struct learn_response
{
    1:i32                   err;
    2:replica_configuration config;
    3:i64                   commit_decree;
    4:i64                   prepare_start_decree;
    5:learn_state           state;
    6:string                base_local_dir;
}

struct group_check_request
{
    1:string                app_type;
    2:dsn.end_point         node;
    3:replica_configuration config;
    4:i64                   last_committed_decree;
    5:i64                   learner_signature;
}

struct group_check_response
{
    1:global_partition_id gpid;
    2:i32                 err;
    3:i64                 last_committed_decree_in_app;
    4:i64                 last_committed_decree_in_prepare_list;
    5:learner_status      learner_status_ = learner_status.LearningFailed;
    6:i64                 learner_signature;
    7:dsn.end_point       node;
}

///////////// demo ///////////////

enum simple_kv_operation
{
    SKV_NOP,
    SKV_UPDATE,
    SKV_READ,
    SKV_APPEND,
}

struct simple_kv_request
{
    1:simple_kv_operation op = simple_kv_operation.SKV_NOP;
    2:string key;
    3:string value;
}

struct simple_kv_response
{
    1:i32  err;
    2:string key;
    3:string value;
}

/////////////////// meta server messages ////////////////////
enum config_type
{
    CT_NONE,
    CT_ASSIGN_PRIMARY,
    CT_ADD_SECONDARY,
    CT_DOWNGRADE_TO_SECONDARY,
    CT_DOWNGRADE_TO_INACTIVE,
    CT_REMOVE,

    // not used by meta server
    CT_UPGRADE_TO_SECONDARY,
}

// primary | secondary(upgrading) (w/ new config) => meta server
struct configuration_update_request
{
    1:partition_configuration  config;
    2:config_type              type = config_type.CT_NONE;
    3:dsn.end_point            node;
}

// meta server (config mgr) => primary | secondary (downgrade) (w/ new config)
struct configuration_update_response
{
    1:i32                      err;
    2:partition_configuration  config;
}

// proposal:  meta server(LBM) => primary  (w/ current config)
struct configuration_proposal_request
{
    1:partition_configuration  config;
    2:config_type              type = config_type.CT_NONE;
    3:dsn.end_point            node;
    4:bool                     is_clean_data = false;
    5:bool                     is_upgrade = false;
}

// client => meta server
struct configuration_node_query_request
{
    1:dsn.end_point    node;
}

// meta server => client
struct configuration_node_query_response
{
    1:i32                           err;
    2:list<partition_configuration> partitions;
}


struct query_replica_decree_request
{
    1:global_partition_id partition_id;
    2:dsn.end_point       node;
}

struct query_replica_decree_response
{
    1:i32                 err;
    2:i64                 last_decree;
}

struct query_configuration_by_index_request
{
    1:string           app_name;
    2:list<i32>        partition_indices;
}

struct query_configuration_by_index_response
{
    1:i32                           err;
    2:list<partition_configuration> partitions;
}

service replica_s
{
	
}

service meta_s
{

}