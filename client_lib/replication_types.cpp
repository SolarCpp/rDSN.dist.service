#ifdef DSN_NOT_USE_DEFAULT_SERIALIZATION
/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include <dsn/dist/replication/replication_types.h>

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace dsn { namespace replication {

int _kpartition_statusValues[] = {
  partition_status::PS_INVALID,
  partition_status::PS_INACTIVE,
  partition_status::PS_ERROR,
  partition_status::PS_PRIMARY,
  partition_status::PS_SECONDARY,
  partition_status::PS_POTENTIAL_SECONDARY
};
const char* _kpartition_statusNames[] = {
  "PS_INVALID",
  "PS_INACTIVE",
  "PS_ERROR",
  "PS_PRIMARY",
  "PS_SECONDARY",
  "PS_POTENTIAL_SECONDARY"
};

int _kread_semanticValues[] = {
  read_semantic::ReadInvalid,
  read_semantic::ReadLastUpdate,
  read_semantic::ReadOutdated,
  read_semantic::ReadSnapshot
};
const char* _kread_semanticNames[] = {
  "ReadInvalid",
  "ReadLastUpdate",
  "ReadOutdated",
  "ReadSnapshot"
};

int _klearn_typeValues[] = {
  learn_type::LT_INVALID,
  learn_type::LT_CACHE,
  learn_type::LT_APP,
  learn_type::LT_LOG
};
const char* _klearn_typeNames[] = {
  "LT_INVALID",
  "LT_CACHE",
  "LT_APP",
  "LT_LOG"
};

int _klearner_statusValues[] = {
  learner_status::LearningInvalid,
  learner_status::LearningWithoutPrepare,
  learner_status::LearningWithPrepareTransient,
  learner_status::LearningWithPrepare,
  learner_status::LearningSucceeded,
  learner_status::LearningFailed
};
const char* _klearner_statusNames[] = {
  "LearningInvalid",
  "LearningWithoutPrepare",
  "LearningWithPrepareTransient",
  "LearningWithPrepare",
  "LearningSucceeded",
  "LearningFailed"
};

int _kconfig_typeValues[] = {
  config_type::CT_INVALID,
  config_type::CT_ASSIGN_PRIMARY,
  config_type::CT_UPGRADE_TO_PRIMARY,
  config_type::CT_ADD_SECONDARY,
  config_type::CT_UPGRADE_TO_SECONDARY,
  config_type::CT_DOWNGRADE_TO_SECONDARY,
  config_type::CT_DOWNGRADE_TO_INACTIVE,
  config_type::CT_REMOVE,
  config_type::CT_ADD_SECONDARY_FOR_LB
};
const char* _kconfig_typeNames[] = {
  "CT_INVALID",
  "CT_ASSIGN_PRIMARY",
  "CT_UPGRADE_TO_PRIMARY",
  "CT_ADD_SECONDARY",
  "CT_UPGRADE_TO_SECONDARY",
  "CT_DOWNGRADE_TO_SECONDARY",
  "CT_DOWNGRADE_TO_INACTIVE",
  "CT_REMOVE",
  "CT_ADD_SECONDARY_FOR_LB"
};

int _kapp_statusValues[] = {
  app_status::AS_INVALID,
  app_status::AS_AVAILABLE,
  app_status::AS_CREATING,
  app_status::AS_CREATE_FAILED,
  app_status::AS_DROPPING,
  app_status::AS_DROP_FAILED,
  app_status::AS_DROPPED
};
const char* _kapp_statusNames[] = {
  "AS_INVALID",
  "AS_AVAILABLE",
  "AS_CREATING",
  "AS_CREATE_FAILED",
  "AS_DROPPING",
  "AS_DROP_FAILED",
  "AS_DROPPED"
};

int _knode_statusValues[] = {
  node_status::NS_INVALID,
  node_status::NS_ALIVE,
  node_status::NS_UNALIVE
};
const char* _knode_statusNames[] = {
  "NS_INVALID",
  "NS_ALIVE",
  "NS_UNALIVE"
};

int _kbalancer_typeValues[] = {
  balancer_type::BT_INVALID,
  balancer_type::BT_MOVE_PRIMARY,
  balancer_type::BT_COPY_PRIMARY,
  balancer_type::BT_COPY_SECONDARY
};
const char* _kbalancer_typeNames[] = {
  "BT_INVALID",
  "BT_MOVE_PRIMARY",
  "BT_COPY_PRIMARY",
  "BT_COPY_SECONDARY"
};


global_partition_id::~global_partition_id() throw() {
}


void global_partition_id::__set_app_id(const int32_t val) {
  this->app_id = val;
}

void global_partition_id::__set_pidx(const int32_t val) {
  this->pidx = val;
}

uint32_t global_partition_id::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->app_id);
          this->__isset.app_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->pidx);
          this->__isset.pidx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t global_partition_id::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("global_partition_id");

  xfer += oprot->writeFieldBegin("app_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->app_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pidx", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->pidx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(global_partition_id &a, global_partition_id &b) {
  using ::std::swap;
  swap(a.app_id, b.app_id);
  swap(a.pidx, b.pidx);
  swap(a.__isset, b.__isset);
}

global_partition_id::global_partition_id(const global_partition_id& other0) {
  app_id = other0.app_id;
  pidx = other0.pidx;
  __isset = other0.__isset;
}
global_partition_id& global_partition_id::operator=(const global_partition_id& other1) {
  app_id = other1.app_id;
  pidx = other1.pidx;
  __isset = other1.__isset;
  return *this;
}
void global_partition_id::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "global_partition_id(";
  out << "app_id=" << to_string(app_id);
  out << ", " << "pidx=" << to_string(pidx);
  out << ")";
}


mutation_header::~mutation_header() throw() {
}


void mutation_header::__set_gpid(const global_partition_id& val) {
  this->gpid = val;
}

void mutation_header::__set_ballot(const int64_t val) {
  this->ballot = val;
}

void mutation_header::__set_decree(const int64_t val) {
  this->decree = val;
}

void mutation_header::__set_log_offset(const int64_t val) {
  this->log_offset = val;
}

void mutation_header::__set_last_committed_decree(const int64_t val) {
  this->last_committed_decree = val;
}

uint32_t mutation_header::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->gpid.read(iprot);
          this->__isset.gpid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ballot);
          this->__isset.ballot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->decree);
          this->__isset.decree = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->log_offset);
          this->__isset.log_offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->last_committed_decree);
          this->__isset.last_committed_decree = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t mutation_header::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("mutation_header");

  xfer += oprot->writeFieldBegin("gpid", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->gpid.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ballot", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->ballot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("decree", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->decree);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("log_offset", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->log_offset);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("last_committed_decree", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->last_committed_decree);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(mutation_header &a, mutation_header &b) {
  using ::std::swap;
  swap(a.gpid, b.gpid);
  swap(a.ballot, b.ballot);
  swap(a.decree, b.decree);
  swap(a.log_offset, b.log_offset);
  swap(a.last_committed_decree, b.last_committed_decree);
  swap(a.__isset, b.__isset);
}

mutation_header::mutation_header(const mutation_header& other2) {
  gpid = other2.gpid;
  ballot = other2.ballot;
  decree = other2.decree;
  log_offset = other2.log_offset;
  last_committed_decree = other2.last_committed_decree;
  __isset = other2.__isset;
}
mutation_header& mutation_header::operator=(const mutation_header& other3) {
  gpid = other3.gpid;
  ballot = other3.ballot;
  decree = other3.decree;
  log_offset = other3.log_offset;
  last_committed_decree = other3.last_committed_decree;
  __isset = other3.__isset;
  return *this;
}
void mutation_header::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "mutation_header(";
  out << "gpid=" << to_string(gpid);
  out << ", " << "ballot=" << to_string(ballot);
  out << ", " << "decree=" << to_string(decree);
  out << ", " << "log_offset=" << to_string(log_offset);
  out << ", " << "last_committed_decree=" << to_string(last_committed_decree);
  out << ")";
}


mutation_update::~mutation_update() throw() {
}


void mutation_update::__set_code(const  ::dsn::task_code& val) {
  this->code = val;
}

void mutation_update::__set_data(const  ::dsn::blob& val) {
  this->data = val;
}

uint32_t mutation_update::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->code.read(iprot);
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t mutation_update::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("mutation_update");

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->code.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(mutation_update &a, mutation_update &b) {
  using ::std::swap;
  swap(a.code, b.code);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

mutation_update::mutation_update(const mutation_update& other4) {
  code = other4.code;
  data = other4.data;
  __isset = other4.__isset;
}
mutation_update& mutation_update::operator=(const mutation_update& other5) {
  code = other5.code;
  data = other5.data;
  __isset = other5.__isset;
  return *this;
}
void mutation_update::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "mutation_update(";
  out << "code=" << to_string(code);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


mutation_data::~mutation_data() throw() {
}


void mutation_data::__set_header(const mutation_header& val) {
  this->header = val;
}

void mutation_data::__set_updates(const std::vector<mutation_update> & val) {
  this->updates = val;
}

uint32_t mutation_data::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->header.read(iprot);
          this->__isset.header = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->updates.clear();
            uint32_t _size6;
            ::apache::thrift::protocol::TType _etype9;
            xfer += iprot->readListBegin(_etype9, _size6);
            this->updates.resize(_size6);
            uint32_t _i10;
            for (_i10 = 0; _i10 < _size6; ++_i10)
            {
              xfer += this->updates[_i10].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.updates = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t mutation_data::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("mutation_data");

  xfer += oprot->writeFieldBegin("header", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->header.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("updates", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->updates.size()));
    std::vector<mutation_update> ::const_iterator _iter11;
    for (_iter11 = this->updates.begin(); _iter11 != this->updates.end(); ++_iter11)
    {
      xfer += (*_iter11).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(mutation_data &a, mutation_data &b) {
  using ::std::swap;
  swap(a.header, b.header);
  swap(a.updates, b.updates);
  swap(a.__isset, b.__isset);
}

mutation_data::mutation_data(const mutation_data& other12) {
  header = other12.header;
  updates = other12.updates;
  __isset = other12.__isset;
}
mutation_data& mutation_data::operator=(const mutation_data& other13) {
  header = other13.header;
  updates = other13.updates;
  __isset = other13.__isset;
  return *this;
}
void mutation_data::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "mutation_data(";
  out << "header=" << to_string(header);
  out << ", " << "updates=" << to_string(updates);
  out << ")";
}


partition_configuration::~partition_configuration() throw() {
}


void partition_configuration::__set_app_type(const std::string& val) {
  this->app_type = val;
}

void partition_configuration::__set_gpid(const global_partition_id& val) {
  this->gpid = val;
}

void partition_configuration::__set_ballot(const int64_t val) {
  this->ballot = val;
}

void partition_configuration::__set_max_replica_count(const int32_t val) {
  this->max_replica_count = val;
}

void partition_configuration::__set_primary(const  ::dsn::rpc_address& val) {
  this->primary = val;
}

void partition_configuration::__set_secondaries(const std::vector< ::dsn::rpc_address> & val) {
  this->secondaries = val;
}

void partition_configuration::__set_last_drops(const std::vector< ::dsn::rpc_address> & val) {
  this->last_drops = val;
}

void partition_configuration::__set_last_committed_decree(const int64_t val) {
  this->last_committed_decree = val;
}

uint32_t partition_configuration::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->app_type);
          this->__isset.app_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->gpid.read(iprot);
          this->__isset.gpid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ballot);
          this->__isset.ballot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->max_replica_count);
          this->__isset.max_replica_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->primary.read(iprot);
          this->__isset.primary = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->secondaries.clear();
            uint32_t _size14;
            ::apache::thrift::protocol::TType _etype17;
            xfer += iprot->readListBegin(_etype17, _size14);
            this->secondaries.resize(_size14);
            uint32_t _i18;
            for (_i18 = 0; _i18 < _size14; ++_i18)
            {
              xfer += this->secondaries[_i18].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.secondaries = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->last_drops.clear();
            uint32_t _size19;
            ::apache::thrift::protocol::TType _etype22;
            xfer += iprot->readListBegin(_etype22, _size19);
            this->last_drops.resize(_size19);
            uint32_t _i23;
            for (_i23 = 0; _i23 < _size19; ++_i23)
            {
              xfer += this->last_drops[_i23].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.last_drops = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->last_committed_decree);
          this->__isset.last_committed_decree = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t partition_configuration::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("partition_configuration");

  xfer += oprot->writeFieldBegin("app_type", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->app_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gpid", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->gpid.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ballot", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->ballot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("max_replica_count", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->max_replica_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("primary", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->primary.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("secondaries", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->secondaries.size()));
    std::vector< ::dsn::rpc_address> ::const_iterator _iter24;
    for (_iter24 = this->secondaries.begin(); _iter24 != this->secondaries.end(); ++_iter24)
    {
      xfer += (*_iter24).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("last_drops", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->last_drops.size()));
    std::vector< ::dsn::rpc_address> ::const_iterator _iter25;
    for (_iter25 = this->last_drops.begin(); _iter25 != this->last_drops.end(); ++_iter25)
    {
      xfer += (*_iter25).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("last_committed_decree", ::apache::thrift::protocol::T_I64, 8);
  xfer += oprot->writeI64(this->last_committed_decree);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(partition_configuration &a, partition_configuration &b) {
  using ::std::swap;
  swap(a.app_type, b.app_type);
  swap(a.gpid, b.gpid);
  swap(a.ballot, b.ballot);
  swap(a.max_replica_count, b.max_replica_count);
  swap(a.primary, b.primary);
  swap(a.secondaries, b.secondaries);
  swap(a.last_drops, b.last_drops);
  swap(a.last_committed_decree, b.last_committed_decree);
  swap(a.__isset, b.__isset);
}

partition_configuration::partition_configuration(const partition_configuration& other26) {
  app_type = other26.app_type;
  gpid = other26.gpid;
  ballot = other26.ballot;
  max_replica_count = other26.max_replica_count;
  primary = other26.primary;
  secondaries = other26.secondaries;
  last_drops = other26.last_drops;
  last_committed_decree = other26.last_committed_decree;
  __isset = other26.__isset;
}
partition_configuration& partition_configuration::operator=(const partition_configuration& other27) {
  app_type = other27.app_type;
  gpid = other27.gpid;
  ballot = other27.ballot;
  max_replica_count = other27.max_replica_count;
  primary = other27.primary;
  secondaries = other27.secondaries;
  last_drops = other27.last_drops;
  last_committed_decree = other27.last_committed_decree;
  __isset = other27.__isset;
  return *this;
}
void partition_configuration::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "partition_configuration(";
  out << "app_type=" << to_string(app_type);
  out << ", " << "gpid=" << to_string(gpid);
  out << ", " << "ballot=" << to_string(ballot);
  out << ", " << "max_replica_count=" << to_string(max_replica_count);
  out << ", " << "primary=" << to_string(primary);
  out << ", " << "secondaries=" << to_string(secondaries);
  out << ", " << "last_drops=" << to_string(last_drops);
  out << ", " << "last_committed_decree=" << to_string(last_committed_decree);
  out << ")";
}


replica_configuration::~replica_configuration() throw() {
}


void replica_configuration::__set_gpid(const global_partition_id& val) {
  this->gpid = val;
}

void replica_configuration::__set_ballot(const int64_t val) {
  this->ballot = val;
}

void replica_configuration::__set_primary(const  ::dsn::rpc_address& val) {
  this->primary = val;
}

void replica_configuration::__set_status(const partition_status val) {
  this->status = val;
}

void replica_configuration::__set_learner_signature(const int64_t val) {
  this->learner_signature = val;
}

uint32_t replica_configuration::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->gpid.read(iprot);
          this->__isset.gpid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ballot);
          this->__isset.ballot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->primary.read(iprot);
          this->__isset.primary = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast28;
          xfer += iprot->readI32(ecast28);
          this->status = (partition_status)ecast28;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->learner_signature);
          this->__isset.learner_signature = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t replica_configuration::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("replica_configuration");

  xfer += oprot->writeFieldBegin("gpid", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->gpid.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ballot", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->ballot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("primary", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->primary.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("learner_signature", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->learner_signature);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(replica_configuration &a, replica_configuration &b) {
  using ::std::swap;
  swap(a.gpid, b.gpid);
  swap(a.ballot, b.ballot);
  swap(a.primary, b.primary);
  swap(a.status, b.status);
  swap(a.learner_signature, b.learner_signature);
  swap(a.__isset, b.__isset);
}

replica_configuration::replica_configuration(const replica_configuration& other29) {
  gpid = other29.gpid;
  ballot = other29.ballot;
  primary = other29.primary;
  status = other29.status;
  learner_signature = other29.learner_signature;
  __isset = other29.__isset;
}
replica_configuration& replica_configuration::operator=(const replica_configuration& other30) {
  gpid = other30.gpid;
  ballot = other30.ballot;
  primary = other30.primary;
  status = other30.status;
  learner_signature = other30.learner_signature;
  __isset = other30.__isset;
  return *this;
}
void replica_configuration::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "replica_configuration(";
  out << "gpid=" << to_string(gpid);
  out << ", " << "ballot=" << to_string(ballot);
  out << ", " << "primary=" << to_string(primary);
  out << ", " << "status=" << to_string(status);
  out << ", " << "learner_signature=" << to_string(learner_signature);
  out << ")";
}


prepare_msg::~prepare_msg() throw() {
}


void prepare_msg::__set_config(const replica_configuration& val) {
  this->config = val;
}

void prepare_msg::__set_mu(const mutation_data& val) {
  this->mu = val;
}

uint32_t prepare_msg::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->config.read(iprot);
          this->__isset.config = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->mu.read(iprot);
          this->__isset.mu = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t prepare_msg::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("prepare_msg");

  xfer += oprot->writeFieldBegin("config", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->config.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mu", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->mu.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(prepare_msg &a, prepare_msg &b) {
  using ::std::swap;
  swap(a.config, b.config);
  swap(a.mu, b.mu);
  swap(a.__isset, b.__isset);
}

prepare_msg::prepare_msg(const prepare_msg& other31) {
  config = other31.config;
  mu = other31.mu;
  __isset = other31.__isset;
}
prepare_msg& prepare_msg::operator=(const prepare_msg& other32) {
  config = other32.config;
  mu = other32.mu;
  __isset = other32.__isset;
  return *this;
}
void prepare_msg::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "prepare_msg(";
  out << "config=" << to_string(config);
  out << ", " << "mu=" << to_string(mu);
  out << ")";
}


read_request_header::~read_request_header() throw() {
}


void read_request_header::__set_gpid(const global_partition_id& val) {
  this->gpid = val;
}

void read_request_header::__set_code(const  ::dsn::task_code& val) {
  this->code = val;
}

void read_request_header::__set_semantic(const read_semantic val) {
  this->semantic = val;
}

void read_request_header::__set_version_decree(const int64_t val) {
  this->version_decree = val;
}

uint32_t read_request_header::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->gpid.read(iprot);
          this->__isset.gpid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->code.read(iprot);
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast33;
          xfer += iprot->readI32(ecast33);
          this->semantic = (read_semantic)ecast33;
          this->__isset.semantic = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->version_decree);
          this->__isset.version_decree = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t read_request_header::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("read_request_header");

  xfer += oprot->writeFieldBegin("gpid", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->gpid.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->code.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("semantic", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->semantic);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version_decree", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->version_decree);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(read_request_header &a, read_request_header &b) {
  using ::std::swap;
  swap(a.gpid, b.gpid);
  swap(a.code, b.code);
  swap(a.semantic, b.semantic);
  swap(a.version_decree, b.version_decree);
  swap(a.__isset, b.__isset);
}

read_request_header::read_request_header(const read_request_header& other34) {
  gpid = other34.gpid;
  code = other34.code;
  semantic = other34.semantic;
  version_decree = other34.version_decree;
  __isset = other34.__isset;
}
read_request_header& read_request_header::operator=(const read_request_header& other35) {
  gpid = other35.gpid;
  code = other35.code;
  semantic = other35.semantic;
  version_decree = other35.version_decree;
  __isset = other35.__isset;
  return *this;
}
void read_request_header::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "read_request_header(";
  out << "gpid=" << to_string(gpid);
  out << ", " << "code=" << to_string(code);
  out << ", " << "semantic=" << to_string(semantic);
  out << ", " << "version_decree=" << to_string(version_decree);
  out << ")";
}


write_request_header::~write_request_header() throw() {
}


void write_request_header::__set_gpid(const global_partition_id& val) {
  this->gpid = val;
}

void write_request_header::__set_code(const  ::dsn::task_code& val) {
  this->code = val;
}

uint32_t write_request_header::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->gpid.read(iprot);
          this->__isset.gpid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->code.read(iprot);
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t write_request_header::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("write_request_header");

  xfer += oprot->writeFieldBegin("gpid", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->gpid.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->code.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(write_request_header &a, write_request_header &b) {
  using ::std::swap;
  swap(a.gpid, b.gpid);
  swap(a.code, b.code);
  swap(a.__isset, b.__isset);
}

write_request_header::write_request_header(const write_request_header& other36) {
  gpid = other36.gpid;
  code = other36.code;
  __isset = other36.__isset;
}
write_request_header& write_request_header::operator=(const write_request_header& other37) {
  gpid = other37.gpid;
  code = other37.code;
  __isset = other37.__isset;
  return *this;
}
void write_request_header::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "write_request_header(";
  out << "gpid=" << to_string(gpid);
  out << ", " << "code=" << to_string(code);
  out << ")";
}


rw_response_header::~rw_response_header() throw() {
}


void rw_response_header::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

uint32_t rw_response_header::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t rw_response_header::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("rw_response_header");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(rw_response_header &a, rw_response_header &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.__isset, b.__isset);
}

rw_response_header::rw_response_header(const rw_response_header& other38) {
  err = other38.err;
  __isset = other38.__isset;
}
rw_response_header& rw_response_header::operator=(const rw_response_header& other39) {
  err = other39.err;
  __isset = other39.__isset;
  return *this;
}
void rw_response_header::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "rw_response_header(";
  out << "err=" << to_string(err);
  out << ")";
}


prepare_ack::~prepare_ack() throw() {
}


void prepare_ack::__set_gpid(const global_partition_id& val) {
  this->gpid = val;
}

void prepare_ack::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void prepare_ack::__set_ballot(const int64_t val) {
  this->ballot = val;
}

void prepare_ack::__set_decree(const int64_t val) {
  this->decree = val;
}

void prepare_ack::__set_last_committed_decree_in_app(const int64_t val) {
  this->last_committed_decree_in_app = val;
}

void prepare_ack::__set_last_committed_decree_in_prepare_list(const int64_t val) {
  this->last_committed_decree_in_prepare_list = val;
}

uint32_t prepare_ack::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->gpid.read(iprot);
          this->__isset.gpid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ballot);
          this->__isset.ballot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->decree);
          this->__isset.decree = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->last_committed_decree_in_app);
          this->__isset.last_committed_decree_in_app = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->last_committed_decree_in_prepare_list);
          this->__isset.last_committed_decree_in_prepare_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t prepare_ack::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("prepare_ack");

  xfer += oprot->writeFieldBegin("gpid", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->gpid.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ballot", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->ballot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("decree", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->decree);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("last_committed_decree_in_app", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->last_committed_decree_in_app);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("last_committed_decree_in_prepare_list", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->last_committed_decree_in_prepare_list);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(prepare_ack &a, prepare_ack &b) {
  using ::std::swap;
  swap(a.gpid, b.gpid);
  swap(a.err, b.err);
  swap(a.ballot, b.ballot);
  swap(a.decree, b.decree);
  swap(a.last_committed_decree_in_app, b.last_committed_decree_in_app);
  swap(a.last_committed_decree_in_prepare_list, b.last_committed_decree_in_prepare_list);
  swap(a.__isset, b.__isset);
}

prepare_ack::prepare_ack(const prepare_ack& other40) {
  gpid = other40.gpid;
  err = other40.err;
  ballot = other40.ballot;
  decree = other40.decree;
  last_committed_decree_in_app = other40.last_committed_decree_in_app;
  last_committed_decree_in_prepare_list = other40.last_committed_decree_in_prepare_list;
  __isset = other40.__isset;
}
prepare_ack& prepare_ack::operator=(const prepare_ack& other41) {
  gpid = other41.gpid;
  err = other41.err;
  ballot = other41.ballot;
  decree = other41.decree;
  last_committed_decree_in_app = other41.last_committed_decree_in_app;
  last_committed_decree_in_prepare_list = other41.last_committed_decree_in_prepare_list;
  __isset = other41.__isset;
  return *this;
}
void prepare_ack::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "prepare_ack(";
  out << "gpid=" << to_string(gpid);
  out << ", " << "err=" << to_string(err);
  out << ", " << "ballot=" << to_string(ballot);
  out << ", " << "decree=" << to_string(decree);
  out << ", " << "last_committed_decree_in_app=" << to_string(last_committed_decree_in_app);
  out << ", " << "last_committed_decree_in_prepare_list=" << to_string(last_committed_decree_in_prepare_list);
  out << ")";
}


learn_state::~learn_state() throw() {
}


void learn_state::__set_from_decree_excluded(const int64_t val) {
  this->from_decree_excluded = val;
}

void learn_state::__set_to_decree_included(const int64_t val) {
  this->to_decree_included = val;
}

void learn_state::__set_meta(const std::vector< ::dsn::blob> & val) {
  this->meta = val;
}

void learn_state::__set_files(const std::vector<std::string> & val) {
  this->files = val;
}

uint32_t learn_state::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->from_decree_excluded);
          this->__isset.from_decree_excluded = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->to_decree_included);
          this->__isset.to_decree_included = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->meta.clear();
            uint32_t _size42;
            ::apache::thrift::protocol::TType _etype45;
            xfer += iprot->readListBegin(_etype45, _size42);
            this->meta.resize(_size42);
            uint32_t _i46;
            for (_i46 = 0; _i46 < _size42; ++_i46)
            {
              xfer += this->meta[_i46].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.meta = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->files.clear();
            uint32_t _size47;
            ::apache::thrift::protocol::TType _etype50;
            xfer += iprot->readListBegin(_etype50, _size47);
            this->files.resize(_size47);
            uint32_t _i51;
            for (_i51 = 0; _i51 < _size47; ++_i51)
            {
              xfer += iprot->readString(this->files[_i51]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.files = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t learn_state::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("learn_state");

  xfer += oprot->writeFieldBegin("from_decree_excluded", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->from_decree_excluded);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("to_decree_included", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->to_decree_included);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("meta", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->meta.size()));
    std::vector< ::dsn::blob> ::const_iterator _iter52;
    for (_iter52 = this->meta.begin(); _iter52 != this->meta.end(); ++_iter52)
    {
      xfer += (*_iter52).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("files", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->files.size()));
    std::vector<std::string> ::const_iterator _iter53;
    for (_iter53 = this->files.begin(); _iter53 != this->files.end(); ++_iter53)
    {
      xfer += oprot->writeString((*_iter53));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(learn_state &a, learn_state &b) {
  using ::std::swap;
  swap(a.from_decree_excluded, b.from_decree_excluded);
  swap(a.to_decree_included, b.to_decree_included);
  swap(a.meta, b.meta);
  swap(a.files, b.files);
  swap(a.__isset, b.__isset);
}

learn_state::learn_state(const learn_state& other54) {
  from_decree_excluded = other54.from_decree_excluded;
  to_decree_included = other54.to_decree_included;
  meta = other54.meta;
  files = other54.files;
  __isset = other54.__isset;
}
learn_state& learn_state::operator=(const learn_state& other55) {
  from_decree_excluded = other55.from_decree_excluded;
  to_decree_included = other55.to_decree_included;
  meta = other55.meta;
  files = other55.files;
  __isset = other55.__isset;
  return *this;
}
void learn_state::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "learn_state(";
  out << "from_decree_excluded=" << to_string(from_decree_excluded);
  out << ", " << "to_decree_included=" << to_string(to_decree_included);
  out << ", " << "meta=" << to_string(meta);
  out << ", " << "files=" << to_string(files);
  out << ")";
}


learn_request::~learn_request() throw() {
}


void learn_request::__set_gpid(const global_partition_id& val) {
  this->gpid = val;
}

void learn_request::__set_learner(const  ::dsn::rpc_address& val) {
  this->learner = val;
}

void learn_request::__set_signature(const int64_t val) {
  this->signature = val;
}

void learn_request::__set_last_committed_decree_in_app(const int64_t val) {
  this->last_committed_decree_in_app = val;
}

void learn_request::__set_last_committed_decree_in_prepare_list(const int64_t val) {
  this->last_committed_decree_in_prepare_list = val;
}

void learn_request::__set_app_specific_learn_request(const  ::dsn::blob& val) {
  this->app_specific_learn_request = val;
}

uint32_t learn_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->gpid.read(iprot);
          this->__isset.gpid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->learner.read(iprot);
          this->__isset.learner = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->signature);
          this->__isset.signature = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->last_committed_decree_in_app);
          this->__isset.last_committed_decree_in_app = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->last_committed_decree_in_prepare_list);
          this->__isset.last_committed_decree_in_prepare_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->app_specific_learn_request.read(iprot);
          this->__isset.app_specific_learn_request = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t learn_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("learn_request");

  xfer += oprot->writeFieldBegin("gpid", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->gpid.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("learner", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->learner.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("signature", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->signature);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("last_committed_decree_in_app", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->last_committed_decree_in_app);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("last_committed_decree_in_prepare_list", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->last_committed_decree_in_prepare_list);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("app_specific_learn_request", ::apache::thrift::protocol::T_STRUCT, 6);
  xfer += this->app_specific_learn_request.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(learn_request &a, learn_request &b) {
  using ::std::swap;
  swap(a.gpid, b.gpid);
  swap(a.learner, b.learner);
  swap(a.signature, b.signature);
  swap(a.last_committed_decree_in_app, b.last_committed_decree_in_app);
  swap(a.last_committed_decree_in_prepare_list, b.last_committed_decree_in_prepare_list);
  swap(a.app_specific_learn_request, b.app_specific_learn_request);
  swap(a.__isset, b.__isset);
}

learn_request::learn_request(const learn_request& other56) {
  gpid = other56.gpid;
  learner = other56.learner;
  signature = other56.signature;
  last_committed_decree_in_app = other56.last_committed_decree_in_app;
  last_committed_decree_in_prepare_list = other56.last_committed_decree_in_prepare_list;
  app_specific_learn_request = other56.app_specific_learn_request;
  __isset = other56.__isset;
}
learn_request& learn_request::operator=(const learn_request& other57) {
  gpid = other57.gpid;
  learner = other57.learner;
  signature = other57.signature;
  last_committed_decree_in_app = other57.last_committed_decree_in_app;
  last_committed_decree_in_prepare_list = other57.last_committed_decree_in_prepare_list;
  app_specific_learn_request = other57.app_specific_learn_request;
  __isset = other57.__isset;
  return *this;
}
void learn_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "learn_request(";
  out << "gpid=" << to_string(gpid);
  out << ", " << "learner=" << to_string(learner);
  out << ", " << "signature=" << to_string(signature);
  out << ", " << "last_committed_decree_in_app=" << to_string(last_committed_decree_in_app);
  out << ", " << "last_committed_decree_in_prepare_list=" << to_string(last_committed_decree_in_prepare_list);
  out << ", " << "app_specific_learn_request=" << to_string(app_specific_learn_request);
  out << ")";
}


learn_response::~learn_response() throw() {
}


void learn_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void learn_response::__set_config(const replica_configuration& val) {
  this->config = val;
}

void learn_response::__set_last_committed_decree(const int64_t val) {
  this->last_committed_decree = val;
}

void learn_response::__set_prepare_start_decree(const int64_t val) {
  this->prepare_start_decree = val;
}

void learn_response::__set_type(const learn_type val) {
  this->type = val;
}

void learn_response::__set_state(const learn_state& val) {
  this->state = val;
}

void learn_response::__set_address(const  ::dsn::rpc_address& val) {
  this->address = val;
}

void learn_response::__set_base_local_dir(const std::string& val) {
  this->base_local_dir = val;
}

uint32_t learn_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->config.read(iprot);
          this->__isset.config = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->last_committed_decree);
          this->__isset.last_committed_decree = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->prepare_start_decree);
          this->__isset.prepare_start_decree = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast58;
          xfer += iprot->readI32(ecast58);
          this->type = (learn_type)ecast58;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->state.read(iprot);
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->address.read(iprot);
          this->__isset.address = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->base_local_dir);
          this->__isset.base_local_dir = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t learn_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("learn_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("config", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->config.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("last_committed_decree", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->last_committed_decree);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("prepare_start_decree", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->prepare_start_decree);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_STRUCT, 6);
  xfer += this->state.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("address", ::apache::thrift::protocol::T_STRUCT, 7);
  xfer += this->address.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("base_local_dir", ::apache::thrift::protocol::T_STRING, 8);
  xfer += oprot->writeString(this->base_local_dir);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(learn_response &a, learn_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.config, b.config);
  swap(a.last_committed_decree, b.last_committed_decree);
  swap(a.prepare_start_decree, b.prepare_start_decree);
  swap(a.type, b.type);
  swap(a.state, b.state);
  swap(a.address, b.address);
  swap(a.base_local_dir, b.base_local_dir);
  swap(a.__isset, b.__isset);
}

learn_response::learn_response(const learn_response& other59) {
  err = other59.err;
  config = other59.config;
  last_committed_decree = other59.last_committed_decree;
  prepare_start_decree = other59.prepare_start_decree;
  type = other59.type;
  state = other59.state;
  address = other59.address;
  base_local_dir = other59.base_local_dir;
  __isset = other59.__isset;
}
learn_response& learn_response::operator=(const learn_response& other60) {
  err = other60.err;
  config = other60.config;
  last_committed_decree = other60.last_committed_decree;
  prepare_start_decree = other60.prepare_start_decree;
  type = other60.type;
  state = other60.state;
  address = other60.address;
  base_local_dir = other60.base_local_dir;
  __isset = other60.__isset;
  return *this;
}
void learn_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "learn_response(";
  out << "err=" << to_string(err);
  out << ", " << "config=" << to_string(config);
  out << ", " << "last_committed_decree=" << to_string(last_committed_decree);
  out << ", " << "prepare_start_decree=" << to_string(prepare_start_decree);
  out << ", " << "type=" << to_string(type);
  out << ", " << "state=" << to_string(state);
  out << ", " << "address=" << to_string(address);
  out << ", " << "base_local_dir=" << to_string(base_local_dir);
  out << ")";
}


group_check_request::~group_check_request() throw() {
}


void group_check_request::__set_app_type(const std::string& val) {
  this->app_type = val;
}

void group_check_request::__set_node(const  ::dsn::rpc_address& val) {
  this->node = val;
}

void group_check_request::__set_config(const replica_configuration& val) {
  this->config = val;
}

void group_check_request::__set_last_committed_decree(const int64_t val) {
  this->last_committed_decree = val;
}

uint32_t group_check_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->app_type);
          this->__isset.app_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->node.read(iprot);
          this->__isset.node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->config.read(iprot);
          this->__isset.config = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->last_committed_decree);
          this->__isset.last_committed_decree = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t group_check_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("group_check_request");

  xfer += oprot->writeFieldBegin("app_type", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->app_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("node", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->node.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("config", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->config.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("last_committed_decree", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->last_committed_decree);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(group_check_request &a, group_check_request &b) {
  using ::std::swap;
  swap(a.app_type, b.app_type);
  swap(a.node, b.node);
  swap(a.config, b.config);
  swap(a.last_committed_decree, b.last_committed_decree);
  swap(a.__isset, b.__isset);
}

group_check_request::group_check_request(const group_check_request& other61) {
  app_type = other61.app_type;
  node = other61.node;
  config = other61.config;
  last_committed_decree = other61.last_committed_decree;
  __isset = other61.__isset;
}
group_check_request& group_check_request::operator=(const group_check_request& other62) {
  app_type = other62.app_type;
  node = other62.node;
  config = other62.config;
  last_committed_decree = other62.last_committed_decree;
  __isset = other62.__isset;
  return *this;
}
void group_check_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "group_check_request(";
  out << "app_type=" << to_string(app_type);
  out << ", " << "node=" << to_string(node);
  out << ", " << "config=" << to_string(config);
  out << ", " << "last_committed_decree=" << to_string(last_committed_decree);
  out << ")";
}


group_check_response::~group_check_response() throw() {
}


void group_check_response::__set_gpid(const global_partition_id& val) {
  this->gpid = val;
}

void group_check_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void group_check_response::__set_last_committed_decree_in_app(const int64_t val) {
  this->last_committed_decree_in_app = val;
}

void group_check_response::__set_last_committed_decree_in_prepare_list(const int64_t val) {
  this->last_committed_decree_in_prepare_list = val;
}

void group_check_response::__set_learner_status_(const learner_status val) {
  this->learner_status_ = val;
}

void group_check_response::__set_learner_signature(const int64_t val) {
  this->learner_signature = val;
}

void group_check_response::__set_node(const  ::dsn::rpc_address& val) {
  this->node = val;
}

uint32_t group_check_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->gpid.read(iprot);
          this->__isset.gpid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->last_committed_decree_in_app);
          this->__isset.last_committed_decree_in_app = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->last_committed_decree_in_prepare_list);
          this->__isset.last_committed_decree_in_prepare_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast63;
          xfer += iprot->readI32(ecast63);
          this->learner_status_ = (learner_status)ecast63;
          this->__isset.learner_status_ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->learner_signature);
          this->__isset.learner_signature = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->node.read(iprot);
          this->__isset.node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t group_check_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("group_check_response");

  xfer += oprot->writeFieldBegin("gpid", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->gpid.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("last_committed_decree_in_app", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->last_committed_decree_in_app);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("last_committed_decree_in_prepare_list", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->last_committed_decree_in_prepare_list);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("learner_status_", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((int32_t)this->learner_status_);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("learner_signature", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->learner_signature);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("node", ::apache::thrift::protocol::T_STRUCT, 7);
  xfer += this->node.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(group_check_response &a, group_check_response &b) {
  using ::std::swap;
  swap(a.gpid, b.gpid);
  swap(a.err, b.err);
  swap(a.last_committed_decree_in_app, b.last_committed_decree_in_app);
  swap(a.last_committed_decree_in_prepare_list, b.last_committed_decree_in_prepare_list);
  swap(a.learner_status_, b.learner_status_);
  swap(a.learner_signature, b.learner_signature);
  swap(a.node, b.node);
  swap(a.__isset, b.__isset);
}

group_check_response::group_check_response(const group_check_response& other64) {
  gpid = other64.gpid;
  err = other64.err;
  last_committed_decree_in_app = other64.last_committed_decree_in_app;
  last_committed_decree_in_prepare_list = other64.last_committed_decree_in_prepare_list;
  learner_status_ = other64.learner_status_;
  learner_signature = other64.learner_signature;
  node = other64.node;
  __isset = other64.__isset;
}
group_check_response& group_check_response::operator=(const group_check_response& other65) {
  gpid = other65.gpid;
  err = other65.err;
  last_committed_decree_in_app = other65.last_committed_decree_in_app;
  last_committed_decree_in_prepare_list = other65.last_committed_decree_in_prepare_list;
  learner_status_ = other65.learner_status_;
  learner_signature = other65.learner_signature;
  node = other65.node;
  __isset = other65.__isset;
  return *this;
}
void group_check_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "group_check_response(";
  out << "gpid=" << to_string(gpid);
  out << ", " << "err=" << to_string(err);
  out << ", " << "last_committed_decree_in_app=" << to_string(last_committed_decree_in_app);
  out << ", " << "last_committed_decree_in_prepare_list=" << to_string(last_committed_decree_in_prepare_list);
  out << ", " << "learner_status_=" << to_string(learner_status_);
  out << ", " << "learner_signature=" << to_string(learner_signature);
  out << ", " << "node=" << to_string(node);
  out << ")";
}


app_info::~app_info() throw() {
}


void app_info::__set_status(const app_status val) {
  this->status = val;
}

void app_info::__set_app_type(const std::string& val) {
  this->app_type = val;
}

void app_info::__set_app_name(const std::string& val) {
  this->app_name = val;
}

void app_info::__set_app_id(const int32_t val) {
  this->app_id = val;
}

void app_info::__set_partition_count(const int32_t val) {
  this->partition_count = val;
}

uint32_t app_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast66;
          xfer += iprot->readI32(ecast66);
          this->status = (app_status)ecast66;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->app_type);
          this->__isset.app_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->app_name);
          this->__isset.app_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->app_id);
          this->__isset.app_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->partition_count);
          this->__isset.partition_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t app_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("app_info");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("app_type", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->app_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("app_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->app_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("app_id", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->app_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partition_count", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->partition_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(app_info &a, app_info &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.app_type, b.app_type);
  swap(a.app_name, b.app_name);
  swap(a.app_id, b.app_id);
  swap(a.partition_count, b.partition_count);
  swap(a.__isset, b.__isset);
}

app_info::app_info(const app_info& other67) {
  status = other67.status;
  app_type = other67.app_type;
  app_name = other67.app_name;
  app_id = other67.app_id;
  partition_count = other67.partition_count;
  __isset = other67.__isset;
}
app_info& app_info::operator=(const app_info& other68) {
  status = other68.status;
  app_type = other68.app_type;
  app_name = other68.app_name;
  app_id = other68.app_id;
  partition_count = other68.partition_count;
  __isset = other68.__isset;
  return *this;
}
void app_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "app_info(";
  out << "status=" << to_string(status);
  out << ", " << "app_type=" << to_string(app_type);
  out << ", " << "app_name=" << to_string(app_name);
  out << ", " << "app_id=" << to_string(app_id);
  out << ", " << "partition_count=" << to_string(partition_count);
  out << ")";
}


node_info::~node_info() throw() {
}


void node_info::__set_status(const node_status val) {
  this->status = val;
}

void node_info::__set_address(const  ::dsn::rpc_address& val) {
  this->address = val;
}

uint32_t node_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast69;
          xfer += iprot->readI32(ecast69);
          this->status = (node_status)ecast69;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->address.read(iprot);
          this->__isset.address = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t node_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("node_info");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("address", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->address.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(node_info &a, node_info &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.address, b.address);
  swap(a.__isset, b.__isset);
}

node_info::node_info(const node_info& other70) {
  status = other70.status;
  address = other70.address;
  __isset = other70.__isset;
}
node_info& node_info::operator=(const node_info& other71) {
  status = other71.status;
  address = other71.address;
  __isset = other71.__isset;
  return *this;
}
void node_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "node_info(";
  out << "status=" << to_string(status);
  out << ", " << "address=" << to_string(address);
  out << ")";
}


meta_response_header::~meta_response_header() throw() {
}


void meta_response_header::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void meta_response_header::__set_primary_address(const  ::dsn::rpc_address& val) {
  this->primary_address = val;
}

uint32_t meta_response_header::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->primary_address.read(iprot);
          this->__isset.primary_address = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t meta_response_header::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("meta_response_header");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("primary_address", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->primary_address.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(meta_response_header &a, meta_response_header &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.primary_address, b.primary_address);
  swap(a.__isset, b.__isset);
}

meta_response_header::meta_response_header(const meta_response_header& other72) {
  err = other72.err;
  primary_address = other72.primary_address;
  __isset = other72.__isset;
}
meta_response_header& meta_response_header::operator=(const meta_response_header& other73) {
  err = other73.err;
  primary_address = other73.primary_address;
  __isset = other73.__isset;
  return *this;
}
void meta_response_header::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "meta_response_header(";
  out << "err=" << to_string(err);
  out << ", " << "primary_address=" << to_string(primary_address);
  out << ")";
}


configuration_update_request::~configuration_update_request() throw() {
}


void configuration_update_request::__set_config(const partition_configuration& val) {
  this->config = val;
}

void configuration_update_request::__set_type(const config_type val) {
  this->type = val;
}

void configuration_update_request::__set_node(const  ::dsn::rpc_address& val) {
  this->node = val;
}

uint32_t configuration_update_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->config.read(iprot);
          this->__isset.config = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast74;
          xfer += iprot->readI32(ecast74);
          this->type = (config_type)ecast74;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->node.read(iprot);
          this->__isset.node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_update_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_update_request");

  xfer += oprot->writeFieldBegin("config", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->config.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("node", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->node.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_update_request &a, configuration_update_request &b) {
  using ::std::swap;
  swap(a.config, b.config);
  swap(a.type, b.type);
  swap(a.node, b.node);
  swap(a.__isset, b.__isset);
}

configuration_update_request::configuration_update_request(const configuration_update_request& other75) {
  config = other75.config;
  type = other75.type;
  node = other75.node;
  __isset = other75.__isset;
}
configuration_update_request& configuration_update_request::operator=(const configuration_update_request& other76) {
  config = other76.config;
  type = other76.type;
  node = other76.node;
  __isset = other76.__isset;
  return *this;
}
void configuration_update_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_update_request(";
  out << "config=" << to_string(config);
  out << ", " << "type=" << to_string(type);
  out << ", " << "node=" << to_string(node);
  out << ")";
}


configuration_update_response::~configuration_update_response() throw() {
}


void configuration_update_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void configuration_update_response::__set_config(const partition_configuration& val) {
  this->config = val;
}

uint32_t configuration_update_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->config.read(iprot);
          this->__isset.config = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_update_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_update_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("config", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->config.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_update_response &a, configuration_update_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.config, b.config);
  swap(a.__isset, b.__isset);
}

configuration_update_response::configuration_update_response(const configuration_update_response& other77) {
  err = other77.err;
  config = other77.config;
  __isset = other77.__isset;
}
configuration_update_response& configuration_update_response::operator=(const configuration_update_response& other78) {
  err = other78.err;
  config = other78.config;
  __isset = other78.__isset;
  return *this;
}
void configuration_update_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_update_response(";
  out << "err=" << to_string(err);
  out << ", " << "config=" << to_string(config);
  out << ")";
}


configuration_proposal_request::~configuration_proposal_request() throw() {
}


void configuration_proposal_request::__set_config(const partition_configuration& val) {
  this->config = val;
}

void configuration_proposal_request::__set_type(const config_type val) {
  this->type = val;
}

void configuration_proposal_request::__set_node(const  ::dsn::rpc_address& val) {
  this->node = val;
}

void configuration_proposal_request::__set_is_clean_data(const bool val) {
  this->is_clean_data = val;
}

void configuration_proposal_request::__set_is_upgrade(const bool val) {
  this->is_upgrade = val;
}

uint32_t configuration_proposal_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->config.read(iprot);
          this->__isset.config = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast79;
          xfer += iprot->readI32(ecast79);
          this->type = (config_type)ecast79;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->node.read(iprot);
          this->__isset.node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_clean_data);
          this->__isset.is_clean_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_upgrade);
          this->__isset.is_upgrade = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_proposal_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_proposal_request");

  xfer += oprot->writeFieldBegin("config", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->config.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("node", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->node.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_clean_data", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->is_clean_data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_upgrade", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->is_upgrade);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_proposal_request &a, configuration_proposal_request &b) {
  using ::std::swap;
  swap(a.config, b.config);
  swap(a.type, b.type);
  swap(a.node, b.node);
  swap(a.is_clean_data, b.is_clean_data);
  swap(a.is_upgrade, b.is_upgrade);
  swap(a.__isset, b.__isset);
}

configuration_proposal_request::configuration_proposal_request(const configuration_proposal_request& other80) {
  config = other80.config;
  type = other80.type;
  node = other80.node;
  is_clean_data = other80.is_clean_data;
  is_upgrade = other80.is_upgrade;
  __isset = other80.__isset;
}
configuration_proposal_request& configuration_proposal_request::operator=(const configuration_proposal_request& other81) {
  config = other81.config;
  type = other81.type;
  node = other81.node;
  is_clean_data = other81.is_clean_data;
  is_upgrade = other81.is_upgrade;
  __isset = other81.__isset;
  return *this;
}
void configuration_proposal_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_proposal_request(";
  out << "config=" << to_string(config);
  out << ", " << "type=" << to_string(type);
  out << ", " << "node=" << to_string(node);
  out << ", " << "is_clean_data=" << to_string(is_clean_data);
  out << ", " << "is_upgrade=" << to_string(is_upgrade);
  out << ")";
}


configuration_query_by_node_request::~configuration_query_by_node_request() throw() {
}


void configuration_query_by_node_request::__set_node(const  ::dsn::rpc_address& val) {
  this->node = val;
}

uint32_t configuration_query_by_node_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->node.read(iprot);
          this->__isset.node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_query_by_node_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_query_by_node_request");

  xfer += oprot->writeFieldBegin("node", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->node.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_query_by_node_request &a, configuration_query_by_node_request &b) {
  using ::std::swap;
  swap(a.node, b.node);
  swap(a.__isset, b.__isset);
}

configuration_query_by_node_request::configuration_query_by_node_request(const configuration_query_by_node_request& other82) {
  node = other82.node;
  __isset = other82.__isset;
}
configuration_query_by_node_request& configuration_query_by_node_request::operator=(const configuration_query_by_node_request& other83) {
  node = other83.node;
  __isset = other83.__isset;
  return *this;
}
void configuration_query_by_node_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_query_by_node_request(";
  out << "node=" << to_string(node);
  out << ")";
}


create_app_options::~create_app_options() throw() {
}


void create_app_options::__set_partition_count(const int32_t val) {
  this->partition_count = val;
}

void create_app_options::__set_replica_count(const int32_t val) {
  this->replica_count = val;
}

void create_app_options::__set_success_if_exist(const bool val) {
  this->success_if_exist = val;
}

void create_app_options::__set_app_type(const std::string& val) {
  this->app_type = val;
}

uint32_t create_app_options::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->partition_count);
          this->__isset.partition_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->replica_count);
          this->__isset.replica_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success_if_exist);
          this->__isset.success_if_exist = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->app_type);
          this->__isset.app_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t create_app_options::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("create_app_options");

  xfer += oprot->writeFieldBegin("partition_count", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->partition_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("replica_count", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->replica_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("success_if_exist", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->success_if_exist);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("app_type", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->app_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(create_app_options &a, create_app_options &b) {
  using ::std::swap;
  swap(a.partition_count, b.partition_count);
  swap(a.replica_count, b.replica_count);
  swap(a.success_if_exist, b.success_if_exist);
  swap(a.app_type, b.app_type);
  swap(a.__isset, b.__isset);
}

create_app_options::create_app_options(const create_app_options& other84) {
  partition_count = other84.partition_count;
  replica_count = other84.replica_count;
  success_if_exist = other84.success_if_exist;
  app_type = other84.app_type;
  __isset = other84.__isset;
}
create_app_options& create_app_options::operator=(const create_app_options& other85) {
  partition_count = other85.partition_count;
  replica_count = other85.replica_count;
  success_if_exist = other85.success_if_exist;
  app_type = other85.app_type;
  __isset = other85.__isset;
  return *this;
}
void create_app_options::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "create_app_options(";
  out << "partition_count=" << to_string(partition_count);
  out << ", " << "replica_count=" << to_string(replica_count);
  out << ", " << "success_if_exist=" << to_string(success_if_exist);
  out << ", " << "app_type=" << to_string(app_type);
  out << ")";
}


configuration_create_app_request::~configuration_create_app_request() throw() {
}


void configuration_create_app_request::__set_app_name(const std::string& val) {
  this->app_name = val;
}

void configuration_create_app_request::__set_options(const create_app_options& val) {
  this->options = val;
}

uint32_t configuration_create_app_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->app_name);
          this->__isset.app_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->options.read(iprot);
          this->__isset.options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_create_app_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_create_app_request");

  xfer += oprot->writeFieldBegin("app_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->app_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("options", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->options.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_create_app_request &a, configuration_create_app_request &b) {
  using ::std::swap;
  swap(a.app_name, b.app_name);
  swap(a.options, b.options);
  swap(a.__isset, b.__isset);
}

configuration_create_app_request::configuration_create_app_request(const configuration_create_app_request& other86) {
  app_name = other86.app_name;
  options = other86.options;
  __isset = other86.__isset;
}
configuration_create_app_request& configuration_create_app_request::operator=(const configuration_create_app_request& other87) {
  app_name = other87.app_name;
  options = other87.options;
  __isset = other87.__isset;
  return *this;
}
void configuration_create_app_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_create_app_request(";
  out << "app_name=" << to_string(app_name);
  out << ", " << "options=" << to_string(options);
  out << ")";
}


drop_app_options::~drop_app_options() throw() {
}


void drop_app_options::__set_success_if_not_exist(const bool val) {
  this->success_if_not_exist = val;
}

uint32_t drop_app_options::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success_if_not_exist);
          this->__isset.success_if_not_exist = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t drop_app_options::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("drop_app_options");

  xfer += oprot->writeFieldBegin("success_if_not_exist", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->success_if_not_exist);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(drop_app_options &a, drop_app_options &b) {
  using ::std::swap;
  swap(a.success_if_not_exist, b.success_if_not_exist);
  swap(a.__isset, b.__isset);
}

drop_app_options::drop_app_options(const drop_app_options& other88) {
  success_if_not_exist = other88.success_if_not_exist;
  __isset = other88.__isset;
}
drop_app_options& drop_app_options::operator=(const drop_app_options& other89) {
  success_if_not_exist = other89.success_if_not_exist;
  __isset = other89.__isset;
  return *this;
}
void drop_app_options::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "drop_app_options(";
  out << "success_if_not_exist=" << to_string(success_if_not_exist);
  out << ")";
}


configuration_drop_app_request::~configuration_drop_app_request() throw() {
}


void configuration_drop_app_request::__set_app_name(const std::string& val) {
  this->app_name = val;
}

void configuration_drop_app_request::__set_options(const drop_app_options& val) {
  this->options = val;
}

uint32_t configuration_drop_app_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->app_name);
          this->__isset.app_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->options.read(iprot);
          this->__isset.options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_drop_app_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_drop_app_request");

  xfer += oprot->writeFieldBegin("app_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->app_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("options", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->options.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_drop_app_request &a, configuration_drop_app_request &b) {
  using ::std::swap;
  swap(a.app_name, b.app_name);
  swap(a.options, b.options);
  swap(a.__isset, b.__isset);
}

configuration_drop_app_request::configuration_drop_app_request(const configuration_drop_app_request& other90) {
  app_name = other90.app_name;
  options = other90.options;
  __isset = other90.__isset;
}
configuration_drop_app_request& configuration_drop_app_request::operator=(const configuration_drop_app_request& other91) {
  app_name = other91.app_name;
  options = other91.options;
  __isset = other91.__isset;
  return *this;
}
void configuration_drop_app_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_drop_app_request(";
  out << "app_name=" << to_string(app_name);
  out << ", " << "options=" << to_string(options);
  out << ")";
}


configuration_list_apps_request::~configuration_list_apps_request() throw() {
}


void configuration_list_apps_request::__set_status(const app_status val) {
  this->status = val;
}

uint32_t configuration_list_apps_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast92;
          xfer += iprot->readI32(ecast92);
          this->status = (app_status)ecast92;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_list_apps_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_list_apps_request");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_list_apps_request &a, configuration_list_apps_request &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

configuration_list_apps_request::configuration_list_apps_request(const configuration_list_apps_request& other93) {
  status = other93.status;
  __isset = other93.__isset;
}
configuration_list_apps_request& configuration_list_apps_request::operator=(const configuration_list_apps_request& other94) {
  status = other94.status;
  __isset = other94.__isset;
  return *this;
}
void configuration_list_apps_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_list_apps_request(";
  out << "status=" << to_string(status);
  out << ")";
}


configuration_list_nodes_request::~configuration_list_nodes_request() throw() {
}


void configuration_list_nodes_request::__set_status(const node_status val) {
  this->status = val;
}

uint32_t configuration_list_nodes_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast95;
          xfer += iprot->readI32(ecast95);
          this->status = (node_status)ecast95;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_list_nodes_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_list_nodes_request");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_list_nodes_request &a, configuration_list_nodes_request &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

configuration_list_nodes_request::configuration_list_nodes_request(const configuration_list_nodes_request& other96) {
  status = other96.status;
  __isset = other96.__isset;
}
configuration_list_nodes_request& configuration_list_nodes_request::operator=(const configuration_list_nodes_request& other97) {
  status = other97.status;
  __isset = other97.__isset;
  return *this;
}
void configuration_list_nodes_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_list_nodes_request(";
  out << "status=" << to_string(status);
  out << ")";
}


configuration_create_app_response::~configuration_create_app_response() throw() {
}


void configuration_create_app_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void configuration_create_app_response::__set_appid(const int32_t val) {
  this->appid = val;
}

uint32_t configuration_create_app_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->appid);
          this->__isset.appid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_create_app_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_create_app_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("appid", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->appid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_create_app_response &a, configuration_create_app_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.appid, b.appid);
  swap(a.__isset, b.__isset);
}

configuration_create_app_response::configuration_create_app_response(const configuration_create_app_response& other98) {
  err = other98.err;
  appid = other98.appid;
  __isset = other98.__isset;
}
configuration_create_app_response& configuration_create_app_response::operator=(const configuration_create_app_response& other99) {
  err = other99.err;
  appid = other99.appid;
  __isset = other99.__isset;
  return *this;
}
void configuration_create_app_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_create_app_response(";
  out << "err=" << to_string(err);
  out << ", " << "appid=" << to_string(appid);
  out << ")";
}


control_balancer_migration_request::~control_balancer_migration_request() throw() {
}


void control_balancer_migration_request::__set_enable_migration(const bool val) {
  this->enable_migration = val;
}

uint32_t control_balancer_migration_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->enable_migration);
          this->__isset.enable_migration = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t control_balancer_migration_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("control_balancer_migration_request");

  xfer += oprot->writeFieldBegin("enable_migration", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->enable_migration);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(control_balancer_migration_request &a, control_balancer_migration_request &b) {
  using ::std::swap;
  swap(a.enable_migration, b.enable_migration);
  swap(a.__isset, b.__isset);
}

control_balancer_migration_request::control_balancer_migration_request(const control_balancer_migration_request& other100) {
  enable_migration = other100.enable_migration;
  __isset = other100.__isset;
}
control_balancer_migration_request& control_balancer_migration_request::operator=(const control_balancer_migration_request& other101) {
  enable_migration = other101.enable_migration;
  __isset = other101.__isset;
  return *this;
}
void control_balancer_migration_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "control_balancer_migration_request(";
  out << "enable_migration=" << to_string(enable_migration);
  out << ")";
}


control_balancer_migration_response::~control_balancer_migration_response() throw() {
}


void control_balancer_migration_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

uint32_t control_balancer_migration_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t control_balancer_migration_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("control_balancer_migration_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(control_balancer_migration_response &a, control_balancer_migration_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.__isset, b.__isset);
}

control_balancer_migration_response::control_balancer_migration_response(const control_balancer_migration_response& other102) {
  err = other102.err;
  __isset = other102.__isset;
}
control_balancer_migration_response& control_balancer_migration_response::operator=(const control_balancer_migration_response& other103) {
  err = other103.err;
  __isset = other103.__isset;
  return *this;
}
void control_balancer_migration_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "control_balancer_migration_response(";
  out << "err=" << to_string(err);
  out << ")";
}


balancer_proposal_request::~balancer_proposal_request() throw() {
}


void balancer_proposal_request::__set_gpid(const global_partition_id& val) {
  this->gpid = val;
}

void balancer_proposal_request::__set_type(const balancer_type val) {
  this->type = val;
}

void balancer_proposal_request::__set_from_addr(const  ::dsn::rpc_address& val) {
  this->from_addr = val;
}

void balancer_proposal_request::__set_to_addr(const  ::dsn::rpc_address& val) {
  this->to_addr = val;
}

uint32_t balancer_proposal_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->gpid.read(iprot);
          this->__isset.gpid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast104;
          xfer += iprot->readI32(ecast104);
          this->type = (balancer_type)ecast104;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->from_addr.read(iprot);
          this->__isset.from_addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->to_addr.read(iprot);
          this->__isset.to_addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t balancer_proposal_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("balancer_proposal_request");

  xfer += oprot->writeFieldBegin("gpid", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->gpid.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("from_addr", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->from_addr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("to_addr", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->to_addr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(balancer_proposal_request &a, balancer_proposal_request &b) {
  using ::std::swap;
  swap(a.gpid, b.gpid);
  swap(a.type, b.type);
  swap(a.from_addr, b.from_addr);
  swap(a.to_addr, b.to_addr);
  swap(a.__isset, b.__isset);
}

balancer_proposal_request::balancer_proposal_request(const balancer_proposal_request& other105) {
  gpid = other105.gpid;
  type = other105.type;
  from_addr = other105.from_addr;
  to_addr = other105.to_addr;
  __isset = other105.__isset;
}
balancer_proposal_request& balancer_proposal_request::operator=(const balancer_proposal_request& other106) {
  gpid = other106.gpid;
  type = other106.type;
  from_addr = other106.from_addr;
  to_addr = other106.to_addr;
  __isset = other106.__isset;
  return *this;
}
void balancer_proposal_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "balancer_proposal_request(";
  out << "gpid=" << to_string(gpid);
  out << ", " << "type=" << to_string(type);
  out << ", " << "from_addr=" << to_string(from_addr);
  out << ", " << "to_addr=" << to_string(to_addr);
  out << ")";
}


balancer_proposal_response::~balancer_proposal_response() throw() {
}


void balancer_proposal_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

uint32_t balancer_proposal_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t balancer_proposal_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("balancer_proposal_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(balancer_proposal_response &a, balancer_proposal_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.__isset, b.__isset);
}

balancer_proposal_response::balancer_proposal_response(const balancer_proposal_response& other107) {
  err = other107.err;
  __isset = other107.__isset;
}
balancer_proposal_response& balancer_proposal_response::operator=(const balancer_proposal_response& other108) {
  err = other108.err;
  __isset = other108.__isset;
  return *this;
}
void balancer_proposal_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "balancer_proposal_response(";
  out << "err=" << to_string(err);
  out << ")";
}


configuration_drop_app_response::~configuration_drop_app_response() throw() {
}


void configuration_drop_app_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

uint32_t configuration_drop_app_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_drop_app_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_drop_app_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_drop_app_response &a, configuration_drop_app_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.__isset, b.__isset);
}

configuration_drop_app_response::configuration_drop_app_response(const configuration_drop_app_response& other109) {
  err = other109.err;
  __isset = other109.__isset;
}
configuration_drop_app_response& configuration_drop_app_response::operator=(const configuration_drop_app_response& other110) {
  err = other110.err;
  __isset = other110.__isset;
  return *this;
}
void configuration_drop_app_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_drop_app_response(";
  out << "err=" << to_string(err);
  out << ")";
}


configuration_list_apps_response::~configuration_list_apps_response() throw() {
}


void configuration_list_apps_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void configuration_list_apps_response::__set_infos(const std::vector<app_info> & val) {
  this->infos = val;
}

uint32_t configuration_list_apps_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->infos.clear();
            uint32_t _size111;
            ::apache::thrift::protocol::TType _etype114;
            xfer += iprot->readListBegin(_etype114, _size111);
            this->infos.resize(_size111);
            uint32_t _i115;
            for (_i115 = 0; _i115 < _size111; ++_i115)
            {
              xfer += this->infos[_i115].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_list_apps_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_list_apps_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("infos", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->infos.size()));
    std::vector<app_info> ::const_iterator _iter116;
    for (_iter116 = this->infos.begin(); _iter116 != this->infos.end(); ++_iter116)
    {
      xfer += (*_iter116).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_list_apps_response &a, configuration_list_apps_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.infos, b.infos);
  swap(a.__isset, b.__isset);
}

configuration_list_apps_response::configuration_list_apps_response(const configuration_list_apps_response& other117) {
  err = other117.err;
  infos = other117.infos;
  __isset = other117.__isset;
}
configuration_list_apps_response& configuration_list_apps_response::operator=(const configuration_list_apps_response& other118) {
  err = other118.err;
  infos = other118.infos;
  __isset = other118.__isset;
  return *this;
}
void configuration_list_apps_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_list_apps_response(";
  out << "err=" << to_string(err);
  out << ", " << "infos=" << to_string(infos);
  out << ")";
}


configuration_list_nodes_response::~configuration_list_nodes_response() throw() {
}


void configuration_list_nodes_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void configuration_list_nodes_response::__set_infos(const std::vector<node_info> & val) {
  this->infos = val;
}

uint32_t configuration_list_nodes_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->infos.clear();
            uint32_t _size119;
            ::apache::thrift::protocol::TType _etype122;
            xfer += iprot->readListBegin(_etype122, _size119);
            this->infos.resize(_size119);
            uint32_t _i123;
            for (_i123 = 0; _i123 < _size119; ++_i123)
            {
              xfer += this->infos[_i123].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.infos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_list_nodes_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_list_nodes_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("infos", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->infos.size()));
    std::vector<node_info> ::const_iterator _iter124;
    for (_iter124 = this->infos.begin(); _iter124 != this->infos.end(); ++_iter124)
    {
      xfer += (*_iter124).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_list_nodes_response &a, configuration_list_nodes_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.infos, b.infos);
  swap(a.__isset, b.__isset);
}

configuration_list_nodes_response::configuration_list_nodes_response(const configuration_list_nodes_response& other125) {
  err = other125.err;
  infos = other125.infos;
  __isset = other125.__isset;
}
configuration_list_nodes_response& configuration_list_nodes_response::operator=(const configuration_list_nodes_response& other126) {
  err = other126.err;
  infos = other126.infos;
  __isset = other126.__isset;
  return *this;
}
void configuration_list_nodes_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_list_nodes_response(";
  out << "err=" << to_string(err);
  out << ", " << "infos=" << to_string(infos);
  out << ")";
}


configuration_query_by_node_response::~configuration_query_by_node_response() throw() {
}


void configuration_query_by_node_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void configuration_query_by_node_response::__set_partitions(const std::vector<partition_configuration> & val) {
  this->partitions = val;
}

uint32_t configuration_query_by_node_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitions.clear();
            uint32_t _size127;
            ::apache::thrift::protocol::TType _etype130;
            xfer += iprot->readListBegin(_etype130, _size127);
            this->partitions.resize(_size127);
            uint32_t _i131;
            for (_i131 = 0; _i131 < _size127; ++_i131)
            {
              xfer += this->partitions[_i131].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_query_by_node_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_query_by_node_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partitions", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitions.size()));
    std::vector<partition_configuration> ::const_iterator _iter132;
    for (_iter132 = this->partitions.begin(); _iter132 != this->partitions.end(); ++_iter132)
    {
      xfer += (*_iter132).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_query_by_node_response &a, configuration_query_by_node_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.partitions, b.partitions);
  swap(a.__isset, b.__isset);
}

configuration_query_by_node_response::configuration_query_by_node_response(const configuration_query_by_node_response& other133) {
  err = other133.err;
  partitions = other133.partitions;
  __isset = other133.__isset;
}
configuration_query_by_node_response& configuration_query_by_node_response::operator=(const configuration_query_by_node_response& other134) {
  err = other134.err;
  partitions = other134.partitions;
  __isset = other134.__isset;
  return *this;
}
void configuration_query_by_node_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_query_by_node_response(";
  out << "err=" << to_string(err);
  out << ", " << "partitions=" << to_string(partitions);
  out << ")";
}


configuration_query_by_index_request::~configuration_query_by_index_request() throw() {
}


void configuration_query_by_index_request::__set_app_name(const std::string& val) {
  this->app_name = val;
}

void configuration_query_by_index_request::__set_partition_indices(const std::vector<int32_t> & val) {
  this->partition_indices = val;
}

uint32_t configuration_query_by_index_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->app_name);
          this->__isset.app_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partition_indices.clear();
            uint32_t _size135;
            ::apache::thrift::protocol::TType _etype138;
            xfer += iprot->readListBegin(_etype138, _size135);
            this->partition_indices.resize(_size135);
            uint32_t _i139;
            for (_i139 = 0; _i139 < _size135; ++_i139)
            {
              xfer += iprot->readI32(this->partition_indices[_i139]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partition_indices = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_query_by_index_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_query_by_index_request");

  xfer += oprot->writeFieldBegin("app_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->app_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partition_indices", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->partition_indices.size()));
    std::vector<int32_t> ::const_iterator _iter140;
    for (_iter140 = this->partition_indices.begin(); _iter140 != this->partition_indices.end(); ++_iter140)
    {
      xfer += oprot->writeI32((*_iter140));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_query_by_index_request &a, configuration_query_by_index_request &b) {
  using ::std::swap;
  swap(a.app_name, b.app_name);
  swap(a.partition_indices, b.partition_indices);
  swap(a.__isset, b.__isset);
}

configuration_query_by_index_request::configuration_query_by_index_request(const configuration_query_by_index_request& other141) {
  app_name = other141.app_name;
  partition_indices = other141.partition_indices;
  __isset = other141.__isset;
}
configuration_query_by_index_request& configuration_query_by_index_request::operator=(const configuration_query_by_index_request& other142) {
  app_name = other142.app_name;
  partition_indices = other142.partition_indices;
  __isset = other142.__isset;
  return *this;
}
void configuration_query_by_index_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_query_by_index_request(";
  out << "app_name=" << to_string(app_name);
  out << ", " << "partition_indices=" << to_string(partition_indices);
  out << ")";
}


configuration_query_by_index_response::~configuration_query_by_index_response() throw() {
}


void configuration_query_by_index_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void configuration_query_by_index_response::__set_app_id(const int32_t val) {
  this->app_id = val;
}

void configuration_query_by_index_response::__set_partition_count(const int32_t val) {
  this->partition_count = val;
}

void configuration_query_by_index_response::__set_partitions(const std::vector<partition_configuration> & val) {
  this->partitions = val;
}

uint32_t configuration_query_by_index_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->app_id);
          this->__isset.app_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->partition_count);
          this->__isset.partition_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitions.clear();
            uint32_t _size143;
            ::apache::thrift::protocol::TType _etype146;
            xfer += iprot->readListBegin(_etype146, _size143);
            this->partitions.resize(_size143);
            uint32_t _i147;
            for (_i147 = 0; _i147 < _size143; ++_i147)
            {
              xfer += this->partitions[_i147].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.partitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t configuration_query_by_index_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("configuration_query_by_index_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("app_id", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->app_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partition_count", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->partition_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("partitions", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->partitions.size()));
    std::vector<partition_configuration> ::const_iterator _iter148;
    for (_iter148 = this->partitions.begin(); _iter148 != this->partitions.end(); ++_iter148)
    {
      xfer += (*_iter148).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(configuration_query_by_index_response &a, configuration_query_by_index_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.app_id, b.app_id);
  swap(a.partition_count, b.partition_count);
  swap(a.partitions, b.partitions);
  swap(a.__isset, b.__isset);
}

configuration_query_by_index_response::configuration_query_by_index_response(const configuration_query_by_index_response& other149) {
  err = other149.err;
  app_id = other149.app_id;
  partition_count = other149.partition_count;
  partitions = other149.partitions;
  __isset = other149.__isset;
}
configuration_query_by_index_response& configuration_query_by_index_response::operator=(const configuration_query_by_index_response& other150) {
  err = other150.err;
  app_id = other150.app_id;
  partition_count = other150.partition_count;
  partitions = other150.partitions;
  __isset = other150.__isset;
  return *this;
}
void configuration_query_by_index_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "configuration_query_by_index_response(";
  out << "err=" << to_string(err);
  out << ", " << "app_id=" << to_string(app_id);
  out << ", " << "partition_count=" << to_string(partition_count);
  out << ", " << "partitions=" << to_string(partitions);
  out << ")";
}


query_replica_decree_request::~query_replica_decree_request() throw() {
}


void query_replica_decree_request::__set_gpid(const global_partition_id& val) {
  this->gpid = val;
}

void query_replica_decree_request::__set_node(const  ::dsn::rpc_address& val) {
  this->node = val;
}

uint32_t query_replica_decree_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->gpid.read(iprot);
          this->__isset.gpid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->node.read(iprot);
          this->__isset.node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t query_replica_decree_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("query_replica_decree_request");

  xfer += oprot->writeFieldBegin("gpid", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->gpid.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("node", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->node.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(query_replica_decree_request &a, query_replica_decree_request &b) {
  using ::std::swap;
  swap(a.gpid, b.gpid);
  swap(a.node, b.node);
  swap(a.__isset, b.__isset);
}

query_replica_decree_request::query_replica_decree_request(const query_replica_decree_request& other151) {
  gpid = other151.gpid;
  node = other151.node;
  __isset = other151.__isset;
}
query_replica_decree_request& query_replica_decree_request::operator=(const query_replica_decree_request& other152) {
  gpid = other152.gpid;
  node = other152.node;
  __isset = other152.__isset;
  return *this;
}
void query_replica_decree_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "query_replica_decree_request(";
  out << "gpid=" << to_string(gpid);
  out << ", " << "node=" << to_string(node);
  out << ")";
}


query_replica_decree_response::~query_replica_decree_response() throw() {
}


void query_replica_decree_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void query_replica_decree_response::__set_last_decree(const int64_t val) {
  this->last_decree = val;
}

uint32_t query_replica_decree_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->last_decree);
          this->__isset.last_decree = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t query_replica_decree_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("query_replica_decree_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("last_decree", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->last_decree);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(query_replica_decree_response &a, query_replica_decree_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.last_decree, b.last_decree);
  swap(a.__isset, b.__isset);
}

query_replica_decree_response::query_replica_decree_response(const query_replica_decree_response& other153) {
  err = other153.err;
  last_decree = other153.last_decree;
  __isset = other153.__isset;
}
query_replica_decree_response& query_replica_decree_response::operator=(const query_replica_decree_response& other154) {
  err = other154.err;
  last_decree = other154.last_decree;
  __isset = other154.__isset;
  return *this;
}
void query_replica_decree_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "query_replica_decree_response(";
  out << "err=" << to_string(err);
  out << ", " << "last_decree=" << to_string(last_decree);
  out << ")";
}


replica_info::~replica_info() throw() {
}


void replica_info::__set_gpid(const global_partition_id& val) {
  this->gpid = val;
}

void replica_info::__set_ballot(const int64_t val) {
  this->ballot = val;
}

void replica_info::__set_status(const partition_status val) {
  this->status = val;
}

void replica_info::__set_last_committed_decree(const int64_t val) {
  this->last_committed_decree = val;
}

void replica_info::__set_last_prepared_decree(const int64_t val) {
  this->last_prepared_decree = val;
}

void replica_info::__set_last_durable_decree(const int64_t val) {
  this->last_durable_decree = val;
}

uint32_t replica_info::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->gpid.read(iprot);
          this->__isset.gpid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ballot);
          this->__isset.ballot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast155;
          xfer += iprot->readI32(ecast155);
          this->status = (partition_status)ecast155;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->last_committed_decree);
          this->__isset.last_committed_decree = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->last_prepared_decree);
          this->__isset.last_prepared_decree = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->last_durable_decree);
          this->__isset.last_durable_decree = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t replica_info::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("replica_info");

  xfer += oprot->writeFieldBegin("gpid", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->gpid.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ballot", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->ballot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("last_committed_decree", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->last_committed_decree);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("last_prepared_decree", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->last_prepared_decree);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("last_durable_decree", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->last_durable_decree);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(replica_info &a, replica_info &b) {
  using ::std::swap;
  swap(a.gpid, b.gpid);
  swap(a.ballot, b.ballot);
  swap(a.status, b.status);
  swap(a.last_committed_decree, b.last_committed_decree);
  swap(a.last_prepared_decree, b.last_prepared_decree);
  swap(a.last_durable_decree, b.last_durable_decree);
  swap(a.__isset, b.__isset);
}

replica_info::replica_info(const replica_info& other156) {
  gpid = other156.gpid;
  ballot = other156.ballot;
  status = other156.status;
  last_committed_decree = other156.last_committed_decree;
  last_prepared_decree = other156.last_prepared_decree;
  last_durable_decree = other156.last_durable_decree;
  __isset = other156.__isset;
}
replica_info& replica_info::operator=(const replica_info& other157) {
  gpid = other157.gpid;
  ballot = other157.ballot;
  status = other157.status;
  last_committed_decree = other157.last_committed_decree;
  last_prepared_decree = other157.last_prepared_decree;
  last_durable_decree = other157.last_durable_decree;
  __isset = other157.__isset;
  return *this;
}
void replica_info::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "replica_info(";
  out << "gpid=" << to_string(gpid);
  out << ", " << "ballot=" << to_string(ballot);
  out << ", " << "status=" << to_string(status);
  out << ", " << "last_committed_decree=" << to_string(last_committed_decree);
  out << ", " << "last_prepared_decree=" << to_string(last_prepared_decree);
  out << ", " << "last_durable_decree=" << to_string(last_durable_decree);
  out << ")";
}


query_replica_info_request::~query_replica_info_request() throw() {
}


void query_replica_info_request::__set_node(const  ::dsn::rpc_address& val) {
  this->node = val;
}

uint32_t query_replica_info_request::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->node.read(iprot);
          this->__isset.node = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t query_replica_info_request::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("query_replica_info_request");

  xfer += oprot->writeFieldBegin("node", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->node.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(query_replica_info_request &a, query_replica_info_request &b) {
  using ::std::swap;
  swap(a.node, b.node);
  swap(a.__isset, b.__isset);
}

query_replica_info_request::query_replica_info_request(const query_replica_info_request& other158) {
  node = other158.node;
  __isset = other158.__isset;
}
query_replica_info_request& query_replica_info_request::operator=(const query_replica_info_request& other159) {
  node = other159.node;
  __isset = other159.__isset;
  return *this;
}
void query_replica_info_request::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "query_replica_info_request(";
  out << "node=" << to_string(node);
  out << ")";
}


query_replica_info_response::~query_replica_info_response() throw() {
}


void query_replica_info_response::__set_err(const  ::dsn::error_code& val) {
  this->err = val;
}

void query_replica_info_response::__set_replicas(const std::vector<replica_info> & val) {
  this->replicas = val;
}

uint32_t query_replica_info_response::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->err.read(iprot);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->replicas.clear();
            uint32_t _size160;
            ::apache::thrift::protocol::TType _etype163;
            xfer += iprot->readListBegin(_etype163, _size160);
            this->replicas.resize(_size160);
            uint32_t _i164;
            for (_i164 = 0; _i164 < _size160; ++_i164)
            {
              xfer += this->replicas[_i164].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.replicas = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t query_replica_info_response::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("query_replica_info_response");

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->err.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("replicas", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->replicas.size()));
    std::vector<replica_info> ::const_iterator _iter165;
    for (_iter165 = this->replicas.begin(); _iter165 != this->replicas.end(); ++_iter165)
    {
      xfer += (*_iter165).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(query_replica_info_response &a, query_replica_info_response &b) {
  using ::std::swap;
  swap(a.err, b.err);
  swap(a.replicas, b.replicas);
  swap(a.__isset, b.__isset);
}

query_replica_info_response::query_replica_info_response(const query_replica_info_response& other166) {
  err = other166.err;
  replicas = other166.replicas;
  __isset = other166.__isset;
}
query_replica_info_response& query_replica_info_response::operator=(const query_replica_info_response& other167) {
  err = other167.err;
  replicas = other167.replicas;
  __isset = other167.__isset;
  return *this;
}
void query_replica_info_response::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "query_replica_info_response(";
  out << "err=" << to_string(err);
  out << ", " << "replicas=" << to_string(replicas);
  out << ")";
}

}} // namespace
#endif
