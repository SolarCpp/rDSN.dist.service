/**
 * Autogenerated by Thrift Compiler (@PACKAGE_VERSION@)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef replication_TYPES_H
#define replication_TYPES_H

# include <dsn/internal/serialization.h>

DEFINE_THREAD_POOL_CODE(THREAD_POOL_REPLICATION)



namespace dsn { namespace replication {

enum partition_status {
  PS_INACTIVE = 0,
  PS_ERROR = 1,
  PS_PRIMARY = 2,
  PS_SECONDARY = 3,
  PS_POTENTIAL_SECONDARY = 4,
  PS_INVALID = 5
};

DEFINE_POD_SERIALIZATION(partition_status);

enum read_semantic_t {
  ReadLastUpdate = 0,
  ReadOutdated = 1,
  ReadSnapshot = 2
};

DEFINE_POD_SERIALIZATION(read_semantic_t);

enum learner_status {
  LearningWithoutPrepare = 0,
  LearningWithPrepare = 1,
  LearningSucceeded = 2,
  LearningFailed = 3,
  Learning_INVALID = 4
};

DEFINE_POD_SERIALIZATION(learner_status);

enum config_type {
  CT_NONE = 0,
  CT_ASSIGN_PRIMARY = 1,
  CT_ADD_SECONDARY = 2,
  CT_DOWNGRADE_TO_SECONDARY = 3,
  CT_DOWNGRADE_TO_INACTIVE = 4,
  CT_REMOVE = 5,
  CT_UPGRADE_TO_SECONDARY = 6
};

DEFINE_POD_SERIALIZATION(config_type);

class global_partition_id;

class mutation_header;

class mutation_data;

class partition_configuration;

class replica_configuration;

class prepare_msg;

class read_request_header;

class write_request_header;

class rw_response_header;

class prepare_ack;

class learn_state;

class learn_request;

class learn_response;

class group_check_request;

class group_check_response;

class meta_request_header;

class meta_response_header;

class configuration_update_request;

class configuration_update_response;

class configuration_proposal_request;

class configuration_query_by_node_request;

class configuration_query_by_node_response;

class configuration_query_by_index_request;

class configuration_query_by_index_response;

class query_replica_decree_request;

class query_replica_decree_response;


class global_partition_id {
 public:

  global_partition_id(const global_partition_id&);
  global_partition_id& operator=(const global_partition_id&);
  global_partition_id() : app_id(-1), pidx(-1) {
  }

  virtual ~global_partition_id() throw();
  int32_t app_id;
  int32_t pidx;
  bool operator == (const global_partition_id & rhs) const
  {
    if (!(app_id == rhs.app_id))
      return false;
    if (!(pidx == rhs.pidx))
      return false;
    return true;
  }
  bool operator != (const global_partition_id &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const global_partition_id & ) const;


};

void swap(global_partition_id &a, global_partition_id &b);

inline void unmarshall(::dsn::binary_reader& reader, __out_param global_partition_id& val) {
  ::dsn::unmarshall(reader, val.app_id);
  ::dsn::unmarshall(reader, val.pidx);
}

inline void marshall(::dsn::binary_writer& writer, const global_partition_id& val, uint16_t pos = 0xffff) {
  ::dsn::marshall(writer, val.app_id, pos);
  ::dsn::marshall(writer, val.pidx, pos);
}


class mutation_header {
 public:

  mutation_header(const mutation_header&);
  mutation_header& operator=(const mutation_header&);
  mutation_header() : ballot(0), decree(0), log_offset(0), last_committed_decree(0) {
  }

  virtual ~mutation_header() throw();
  global_partition_id gpid;
  int64_t ballot;
  int64_t decree;
  int64_t log_offset;
  int64_t last_committed_decree;
  bool operator == (const mutation_header & rhs) const
  {
    if (!(gpid == rhs.gpid))
      return false;
    if (!(ballot == rhs.ballot))
      return false;
    if (!(decree == rhs.decree))
      return false;
    if (!(log_offset == rhs.log_offset))
      return false;
    if (!(last_committed_decree == rhs.last_committed_decree))
      return false;
    return true;
  }
  bool operator != (const mutation_header &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const mutation_header & ) const;


};

void swap(mutation_header &a, mutation_header &b);

inline void unmarshall(::dsn::binary_reader& reader, __out_param mutation_header& val) {
  unmarshall(reader, val.gpid);
  ::dsn::unmarshall(reader, val.ballot);
  ::dsn::unmarshall(reader, val.decree);
  ::dsn::unmarshall(reader, val.log_offset);
  ::dsn::unmarshall(reader, val.last_committed_decree);
}

inline void marshall(::dsn::binary_writer& writer, const mutation_header& val, uint16_t pos = 0xffff) {
  marshall(writer, val.gpid, pos);
  ::dsn::marshall(writer, val.ballot, pos);
  ::dsn::marshall(writer, val.decree, pos);
  ::dsn::marshall(writer, val.log_offset, pos);
  ::dsn::marshall(writer, val.last_committed_decree, pos);
}


class mutation_data {
 public:

  mutation_data(const mutation_data&);
  mutation_data& operator=(const mutation_data&);
  mutation_data() {
  }

  virtual ~mutation_data() throw();
  mutation_header header;
  std::vector< ::dsn::blob>  updates;
  bool operator == (const mutation_data & rhs) const
  {
    if (!(header == rhs.header))
      return false;
    if (!(updates == rhs.updates))
      return false;
    return true;
  }
  bool operator != (const mutation_data &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const mutation_data & ) const;


};

void swap(mutation_data &a, mutation_data &b);

inline void unmarshall(::dsn::binary_reader& reader, __out_param mutation_data& val) {
  unmarshall(reader, val.header);
  unmarshall(reader, val.updates);
}

inline void marshall(::dsn::binary_writer& writer, const mutation_data& val, uint16_t pos = 0xffff) {
  marshall(writer, val.header, pos);
  marshall(writer, val.updates, pos);
}


class partition_configuration {
 public:

  partition_configuration(const partition_configuration&);
  partition_configuration& operator=(const partition_configuration&);
  partition_configuration() : app_type(), ballot(0), max_replica_count(0), last_committed_decree(0) {
  }

  virtual ~partition_configuration() throw();
  std::string app_type;
  global_partition_id gpid;
  int64_t ballot;
  int32_t max_replica_count;
   ::dsn::end_point primary;
  std::vector< ::dsn::end_point>  secondaries;
  std::vector< ::dsn::end_point>  drop_outs;
  int64_t last_committed_decree;
  bool operator == (const partition_configuration & rhs) const
  {
    if (!(app_type == rhs.app_type))
      return false;
    if (!(gpid == rhs.gpid))
      return false;
    if (!(ballot == rhs.ballot))
      return false;
    if (!(max_replica_count == rhs.max_replica_count))
      return false;
    if (!(primary == rhs.primary))
      return false;
    if (!(secondaries == rhs.secondaries))
      return false;
    if (!(drop_outs == rhs.drop_outs))
      return false;
    if (!(last_committed_decree == rhs.last_committed_decree))
      return false;
    return true;
  }
  bool operator != (const partition_configuration &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const partition_configuration & ) const;


};

void swap(partition_configuration &a, partition_configuration &b);

inline void unmarshall(::dsn::binary_reader& reader, __out_param partition_configuration& val) {
  ::dsn::unmarshall(reader, val.app_type);
  unmarshall(reader, val.gpid);
  ::dsn::unmarshall(reader, val.ballot);
  ::dsn::unmarshall(reader, val.max_replica_count);
  unmarshall(reader, val.primary);
  unmarshall(reader, val.secondaries);
  unmarshall(reader, val.drop_outs);
  ::dsn::unmarshall(reader, val.last_committed_decree);
}

inline void marshall(::dsn::binary_writer& writer, const partition_configuration& val, uint16_t pos = 0xffff) {
  ::dsn::marshall(writer, val.app_type, pos);
  marshall(writer, val.gpid, pos);
  ::dsn::marshall(writer, val.ballot, pos);
  ::dsn::marshall(writer, val.max_replica_count, pos);
  marshall(writer, val.primary, pos);
  marshall(writer, val.secondaries, pos);
  marshall(writer, val.drop_outs, pos);
  ::dsn::marshall(writer, val.last_committed_decree, pos);
}


class replica_configuration {
 public:

  replica_configuration(const replica_configuration&);
  replica_configuration& operator=(const replica_configuration&);
  replica_configuration() : ballot(0), status((partition_status)0) {
    status = (partition_status)0;

  }

  virtual ~replica_configuration() throw();
  global_partition_id gpid;
  int64_t ballot;
   ::dsn::end_point primary;
  partition_status status;
  bool operator == (const replica_configuration & rhs) const
  {
    if (!(gpid == rhs.gpid))
      return false;
    if (!(ballot == rhs.ballot))
      return false;
    if (!(primary == rhs.primary))
      return false;
    if (!(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const replica_configuration &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const replica_configuration & ) const;


};

void swap(replica_configuration &a, replica_configuration &b);

inline void unmarshall(::dsn::binary_reader& reader, __out_param replica_configuration& val) {
  unmarshall(reader, val.gpid);
  ::dsn::unmarshall(reader, val.ballot);
  unmarshall(reader, val.primary);
  unmarshall(reader, val.status);
}

inline void marshall(::dsn::binary_writer& writer, const replica_configuration& val, uint16_t pos = 0xffff) {
  marshall(writer, val.gpid, pos);
  ::dsn::marshall(writer, val.ballot, pos);
  marshall(writer, val.primary, pos);
  marshall(writer, val.status, pos);
}


class prepare_msg {
 public:

  prepare_msg(const prepare_msg&);
  prepare_msg& operator=(const prepare_msg&);
  prepare_msg() {
  }

  virtual ~prepare_msg() throw();
  replica_configuration config;
  mutation_data mu;
  bool operator == (const prepare_msg & rhs) const
  {
    if (!(config == rhs.config))
      return false;
    if (!(mu == rhs.mu))
      return false;
    return true;
  }
  bool operator != (const prepare_msg &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const prepare_msg & ) const;


};

void swap(prepare_msg &a, prepare_msg &b);

inline void unmarshall(::dsn::binary_reader& reader, __out_param prepare_msg& val) {
  unmarshall(reader, val.config);
  unmarshall(reader, val.mu);
}

inline void marshall(::dsn::binary_writer& writer, const prepare_msg& val, uint16_t pos = 0xffff) {
  marshall(writer, val.config, pos);
  marshall(writer, val.mu, pos);
}


class read_request_header {
 public:

  read_request_header(const read_request_header&);
  read_request_header& operator=(const read_request_header&);
  read_request_header() : code(0), semantic((read_semantic_t)0), version_decree(-1LL) {
    semantic = (read_semantic_t)0;

  }

  virtual ~read_request_header() throw();
  global_partition_id gpid;
  int32_t code;
  read_semantic_t semantic;
  int64_t version_decree;
  bool operator == (const read_request_header & rhs) const
  {
    if (!(gpid == rhs.gpid))
      return false;
    if (!(code == rhs.code))
      return false;
    if (!(semantic == rhs.semantic))
      return false;
    if (!(version_decree == rhs.version_decree))
      return false;
    return true;
  }
  bool operator != (const read_request_header &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const read_request_header & ) const;


};

void swap(read_request_header &a, read_request_header &b);

inline void unmarshall(::dsn::binary_reader& reader, __out_param read_request_header& val) {
  unmarshall(reader, val.gpid);
  ::dsn::unmarshall(reader, val.code);
  unmarshall(reader, val.semantic);
  ::dsn::unmarshall(reader, val.version_decree);
}

inline void marshall(::dsn::binary_writer& writer, const read_request_header& val, uint16_t pos = 0xffff) {
  marshall(writer, val.gpid, pos);
  ::dsn::marshall(writer, val.code, pos);
  marshall(writer, val.semantic, pos);
  ::dsn::marshall(writer, val.version_decree, pos);
}


class write_request_header {
 public:

  write_request_header(const write_request_header&);
  write_request_header& operator=(const write_request_header&);
  write_request_header() : code(0) {
  }

  virtual ~write_request_header() throw();
  global_partition_id gpid;
  int32_t code;
  bool operator == (const write_request_header & rhs) const
  {
    if (!(gpid == rhs.gpid))
      return false;
    if (!(code == rhs.code))
      return false;
    return true;
  }
  bool operator != (const write_request_header &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const write_request_header & ) const;


};

void swap(write_request_header &a, write_request_header &b);

inline void unmarshall(::dsn::binary_reader& reader, __out_param write_request_header& val) {
  unmarshall(reader, val.gpid);
  ::dsn::unmarshall(reader, val.code);
}

inline void marshall(::dsn::binary_writer& writer, const write_request_header& val, uint16_t pos = 0xffff) {
  marshall(writer, val.gpid, pos);
  ::dsn::marshall(writer, val.code, pos);
}


class rw_response_header {
 public:

  rw_response_header(const rw_response_header&);
  rw_response_header& operator=(const rw_response_header&);
  rw_response_header() : err(0) {
  }

  virtual ~rw_response_header() throw();
  int32_t err;
  bool operator == (const rw_response_header & rhs) const
  {
    if (!(err == rhs.err))
      return false;
    return true;
  }
  bool operator != (const rw_response_header &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const rw_response_header & ) const;


};

void swap(rw_response_header &a, rw_response_header &b);

inline void unmarshall(::dsn::binary_reader& reader, __out_param rw_response_header& val) {
  ::dsn::unmarshall(reader, val.err);
}

inline void marshall(::dsn::binary_writer& writer, const rw_response_header& val, uint16_t pos = 0xffff) {
  ::dsn::marshall(writer, val.err, pos);
}


class prepare_ack {
 public:

  prepare_ack(const prepare_ack&);
  prepare_ack& operator=(const prepare_ack&);
  prepare_ack() : err(0), ballot(0), decree(0), last_committed_decree_in_app(0), last_committed_decree_in_prepare_list(0) {
  }

  virtual ~prepare_ack() throw();
  global_partition_id gpid;
  int32_t err;
  int64_t ballot;
  int64_t decree;
  int64_t last_committed_decree_in_app;
  int64_t last_committed_decree_in_prepare_list;
  bool operator == (const prepare_ack & rhs) const
  {
    if (!(gpid == rhs.gpid))
      return false;
    if (!(err == rhs.err))
      return false;
    if (!(ballot == rhs.ballot))
      return false;
    if (!(decree == rhs.decree))
      return false;
    if (!(last_committed_decree_in_app == rhs.last_committed_decree_in_app))
      return false;
    if (!(last_committed_decree_in_prepare_list == rhs.last_committed_decree_in_prepare_list))
      return false;
    return true;
  }
  bool operator != (const prepare_ack &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const prepare_ack & ) const;


};

void swap(prepare_ack &a, prepare_ack &b);

inline void unmarshall(::dsn::binary_reader& reader, __out_param prepare_ack& val) {
  unmarshall(reader, val.gpid);
  ::dsn::unmarshall(reader, val.err);
  ::dsn::unmarshall(reader, val.ballot);
  ::dsn::unmarshall(reader, val.decree);
  ::dsn::unmarshall(reader, val.last_committed_decree_in_app);
  ::dsn::unmarshall(reader, val.last_committed_decree_in_prepare_list);
}

inline void marshall(::dsn::binary_writer& writer, const prepare_ack& val, uint16_t pos = 0xffff) {
  marshall(writer, val.gpid, pos);
  ::dsn::marshall(writer, val.err, pos);
  ::dsn::marshall(writer, val.ballot, pos);
  ::dsn::marshall(writer, val.decree, pos);
  ::dsn::marshall(writer, val.last_committed_decree_in_app, pos);
  ::dsn::marshall(writer, val.last_committed_decree_in_prepare_list, pos);
}


class learn_state {
 public:

  learn_state(const learn_state&);
  learn_state& operator=(const learn_state&);
  learn_state() {
  }

  virtual ~learn_state() throw();
   ::dsn::blob meta;
  std::vector<std::string>  files;
  bool operator == (const learn_state & rhs) const
  {
    if (!(meta == rhs.meta))
      return false;
    if (!(files == rhs.files))
      return false;
    return true;
  }
  bool operator != (const learn_state &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const learn_state & ) const;


};

void swap(learn_state &a, learn_state &b);

inline void unmarshall(::dsn::binary_reader& reader, __out_param learn_state& val) {
  unmarshall(reader, val.meta);
  unmarshall(reader, val.files);
}

inline void marshall(::dsn::binary_writer& writer, const learn_state& val, uint16_t pos = 0xffff) {
  marshall(writer, val.meta, pos);
  marshall(writer, val.files, pos);
}


class learn_request {
 public:

  learn_request(const learn_request&);
  learn_request& operator=(const learn_request&);
  learn_request() : signature(0), last_committed_decree_in_app(0), last_committed_decree_in_prepare_list(0) {
  }

  virtual ~learn_request() throw();
  global_partition_id gpid;
   ::dsn::end_point learner;
  int64_t signature;
  int64_t last_committed_decree_in_app;
  int64_t last_committed_decree_in_prepare_list;
   ::dsn::blob app_specific_learn_request;
  bool operator == (const learn_request & rhs) const
  {
    if (!(gpid == rhs.gpid))
      return false;
    if (!(learner == rhs.learner))
      return false;
    if (!(signature == rhs.signature))
      return false;
    if (!(last_committed_decree_in_app == rhs.last_committed_decree_in_app))
      return false;
    if (!(last_committed_decree_in_prepare_list == rhs.last_committed_decree_in_prepare_list))
      return false;
    if (!(app_specific_learn_request == rhs.app_specific_learn_request))
      return false;
    return true;
  }
  bool operator != (const learn_request &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const learn_request & ) const;


};

void swap(learn_request &a, learn_request &b);

inline void unmarshall(::dsn::binary_reader& reader, __out_param learn_request& val) {
  unmarshall(reader, val.gpid);
  unmarshall(reader, val.learner);
  ::dsn::unmarshall(reader, val.signature);
  ::dsn::unmarshall(reader, val.last_committed_decree_in_app);
  ::dsn::unmarshall(reader, val.last_committed_decree_in_prepare_list);
  unmarshall(reader, val.app_specific_learn_request);
}

inline void marshall(::dsn::binary_writer& writer, const learn_request& val, uint16_t pos = 0xffff) {
  marshall(writer, val.gpid, pos);
  marshall(writer, val.learner, pos);
  ::dsn::marshall(writer, val.signature, pos);
  ::dsn::marshall(writer, val.last_committed_decree_in_app, pos);
  ::dsn::marshall(writer, val.last_committed_decree_in_prepare_list, pos);
  marshall(writer, val.app_specific_learn_request, pos);
}


class learn_response {
 public:

  learn_response(const learn_response&);
  learn_response& operator=(const learn_response&);
  learn_response() : err(0), commit_decree(0), prepare_start_decree(0), base_local_dir() {
  }

  virtual ~learn_response() throw();
  int32_t err;
  replica_configuration config;
  int64_t commit_decree;
  int64_t prepare_start_decree;
  learn_state state;
  std::string base_local_dir;
  bool operator == (const learn_response & rhs) const
  {
    if (!(err == rhs.err))
      return false;
    if (!(config == rhs.config))
      return false;
    if (!(commit_decree == rhs.commit_decree))
      return false;
    if (!(prepare_start_decree == rhs.prepare_start_decree))
      return false;
    if (!(state == rhs.state))
      return false;
    if (!(base_local_dir == rhs.base_local_dir))
      return false;
    return true;
  }
  bool operator != (const learn_response &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const learn_response & ) const;


};

void swap(learn_response &a, learn_response &b);

inline void unmarshall(::dsn::binary_reader& reader, __out_param learn_response& val) {
  ::dsn::unmarshall(reader, val.err);
  unmarshall(reader, val.config);
  ::dsn::unmarshall(reader, val.commit_decree);
  ::dsn::unmarshall(reader, val.prepare_start_decree);
  unmarshall(reader, val.state);
  ::dsn::unmarshall(reader, val.base_local_dir);
}

inline void marshall(::dsn::binary_writer& writer, const learn_response& val, uint16_t pos = 0xffff) {
  ::dsn::marshall(writer, val.err, pos);
  marshall(writer, val.config, pos);
  ::dsn::marshall(writer, val.commit_decree, pos);
  ::dsn::marshall(writer, val.prepare_start_decree, pos);
  marshall(writer, val.state, pos);
  ::dsn::marshall(writer, val.base_local_dir, pos);
}


class group_check_request {
 public:

  group_check_request(const group_check_request&);
  group_check_request& operator=(const group_check_request&);
  group_check_request() : app_type(), last_committed_decree(0), learner_signature(0) {
  }

  virtual ~group_check_request() throw();
  std::string app_type;
   ::dsn::end_point node;
  replica_configuration config;
  int64_t last_committed_decree;
  int64_t learner_signature;
  bool operator == (const group_check_request & rhs) const
  {
    if (!(app_type == rhs.app_type))
      return false;
    if (!(node == rhs.node))
      return false;
    if (!(config == rhs.config))
      return false;
    if (!(last_committed_decree == rhs.last_committed_decree))
      return false;
    if (!(learner_signature == rhs.learner_signature))
      return false;
    return true;
  }
  bool operator != (const group_check_request &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const group_check_request & ) const;


};

void swap(group_check_request &a, group_check_request &b);

inline void unmarshall(::dsn::binary_reader& reader, __out_param group_check_request& val) {
  ::dsn::unmarshall(reader, val.app_type);
  unmarshall(reader, val.node);
  unmarshall(reader, val.config);
  ::dsn::unmarshall(reader, val.last_committed_decree);
  ::dsn::unmarshall(reader, val.learner_signature);
}

inline void marshall(::dsn::binary_writer& writer, const group_check_request& val, uint16_t pos = 0xffff) {
  ::dsn::marshall(writer, val.app_type, pos);
  marshall(writer, val.node, pos);
  marshall(writer, val.config, pos);
  ::dsn::marshall(writer, val.last_committed_decree, pos);
  ::dsn::marshall(writer, val.learner_signature, pos);
}


class group_check_response {
 public:

  group_check_response(const group_check_response&);
  group_check_response& operator=(const group_check_response&);
  group_check_response() : err(0), last_committed_decree_in_app(0), last_committed_decree_in_prepare_list(0), learner_status_((learner_status)3), learner_signature(0) {
    learner_status_ = (learner_status)3;

  }

  virtual ~group_check_response() throw();
  global_partition_id gpid;
  int32_t err;
  int64_t last_committed_decree_in_app;
  int64_t last_committed_decree_in_prepare_list;
  learner_status learner_status_;
  int64_t learner_signature;
   ::dsn::end_point node;
  bool operator == (const group_check_response & rhs) const
  {
    if (!(gpid == rhs.gpid))
      return false;
    if (!(err == rhs.err))
      return false;
    if (!(last_committed_decree_in_app == rhs.last_committed_decree_in_app))
      return false;
    if (!(last_committed_decree_in_prepare_list == rhs.last_committed_decree_in_prepare_list))
      return false;
    if (!(learner_status_ == rhs.learner_status_))
      return false;
    if (!(learner_signature == rhs.learner_signature))
      return false;
    if (!(node == rhs.node))
      return false;
    return true;
  }
  bool operator != (const group_check_response &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const group_check_response & ) const;


};

void swap(group_check_response &a, group_check_response &b);

inline void unmarshall(::dsn::binary_reader& reader, __out_param group_check_response& val) {
  unmarshall(reader, val.gpid);
  ::dsn::unmarshall(reader, val.err);
  ::dsn::unmarshall(reader, val.last_committed_decree_in_app);
  ::dsn::unmarshall(reader, val.last_committed_decree_in_prepare_list);
  unmarshall(reader, val.learner_status_);
  ::dsn::unmarshall(reader, val.learner_signature);
  unmarshall(reader, val.node);
}

inline void marshall(::dsn::binary_writer& writer, const group_check_response& val, uint16_t pos = 0xffff) {
  marshall(writer, val.gpid, pos);
  ::dsn::marshall(writer, val.err, pos);
  ::dsn::marshall(writer, val.last_committed_decree_in_app, pos);
  ::dsn::marshall(writer, val.last_committed_decree_in_prepare_list, pos);
  marshall(writer, val.learner_status_, pos);
  ::dsn::marshall(writer, val.learner_signature, pos);
  marshall(writer, val.node, pos);
}


class meta_request_header {
 public:

  meta_request_header(const meta_request_header&);
  meta_request_header& operator=(const meta_request_header&);
  meta_request_header() : rpc_tag(0) {
  }

  virtual ~meta_request_header() throw();
  int32_t rpc_tag;
  bool operator == (const meta_request_header & rhs) const
  {
    if (!(rpc_tag == rhs.rpc_tag))
      return false;
    return true;
  }
  bool operator != (const meta_request_header &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const meta_request_header & ) const;


};

void swap(meta_request_header &a, meta_request_header &b);

inline void unmarshall(::dsn::binary_reader& reader, __out_param meta_request_header& val) {
  ::dsn::unmarshall(reader, val.rpc_tag);
}

inline void marshall(::dsn::binary_writer& writer, const meta_request_header& val, uint16_t pos = 0xffff) {
  ::dsn::marshall(writer, val.rpc_tag, pos);
}


class meta_response_header {
 public:

  meta_response_header(const meta_response_header&);
  meta_response_header& operator=(const meta_response_header&);
  meta_response_header() : err(0) {
  }

  virtual ~meta_response_header() throw();
  int32_t err;
   ::dsn::end_point primary_address;
  bool operator == (const meta_response_header & rhs) const
  {
    if (!(err == rhs.err))
      return false;
    if (!(primary_address == rhs.primary_address))
      return false;
    return true;
  }
  bool operator != (const meta_response_header &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const meta_response_header & ) const;


};

void swap(meta_response_header &a, meta_response_header &b);

inline void unmarshall(::dsn::binary_reader& reader, __out_param meta_response_header& val) {
  ::dsn::unmarshall(reader, val.err);
  unmarshall(reader, val.primary_address);
}

inline void marshall(::dsn::binary_writer& writer, const meta_response_header& val, uint16_t pos = 0xffff) {
  ::dsn::marshall(writer, val.err, pos);
  marshall(writer, val.primary_address, pos);
}


class configuration_update_request {
 public:

  configuration_update_request(const configuration_update_request&);
  configuration_update_request& operator=(const configuration_update_request&);
  configuration_update_request() : type((config_type)0) {
    type = (config_type)0;

  }

  virtual ~configuration_update_request() throw();
  partition_configuration config;
  config_type type;
   ::dsn::end_point node;
  bool operator == (const configuration_update_request & rhs) const
  {
    if (!(config == rhs.config))
      return false;
    if (!(type == rhs.type))
      return false;
    if (!(node == rhs.node))
      return false;
    return true;
  }
  bool operator != (const configuration_update_request &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const configuration_update_request & ) const;


};

void swap(configuration_update_request &a, configuration_update_request &b);

inline void unmarshall(::dsn::binary_reader& reader, __out_param configuration_update_request& val) {
  unmarshall(reader, val.config);
  unmarshall(reader, val.type);
  unmarshall(reader, val.node);
}

inline void marshall(::dsn::binary_writer& writer, const configuration_update_request& val, uint16_t pos = 0xffff) {
  marshall(writer, val.config, pos);
  marshall(writer, val.type, pos);
  marshall(writer, val.node, pos);
}


class configuration_update_response {
 public:

  configuration_update_response(const configuration_update_response&);
  configuration_update_response& operator=(const configuration_update_response&);
  configuration_update_response() : err(0) {
  }

  virtual ~configuration_update_response() throw();
  int32_t err;
  partition_configuration config;
  bool operator == (const configuration_update_response & rhs) const
  {
    if (!(err == rhs.err))
      return false;
    if (!(config == rhs.config))
      return false;
    return true;
  }
  bool operator != (const configuration_update_response &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const configuration_update_response & ) const;


};

void swap(configuration_update_response &a, configuration_update_response &b);

inline void unmarshall(::dsn::binary_reader& reader, __out_param configuration_update_response& val) {
  ::dsn::unmarshall(reader, val.err);
  unmarshall(reader, val.config);
}

inline void marshall(::dsn::binary_writer& writer, const configuration_update_response& val, uint16_t pos = 0xffff) {
  ::dsn::marshall(writer, val.err, pos);
  marshall(writer, val.config, pos);
}


class configuration_proposal_request {
 public:

  configuration_proposal_request(const configuration_proposal_request&);
  configuration_proposal_request& operator=(const configuration_proposal_request&);
  configuration_proposal_request() : type((config_type)0), is_clean_data(false), is_upgrade(false) {
    type = (config_type)0;

  }

  virtual ~configuration_proposal_request() throw();
  partition_configuration config;
  config_type type;
   ::dsn::end_point node;
  bool is_clean_data;
  bool is_upgrade;
  bool operator == (const configuration_proposal_request & rhs) const
  {
    if (!(config == rhs.config))
      return false;
    if (!(type == rhs.type))
      return false;
    if (!(node == rhs.node))
      return false;
    if (!(is_clean_data == rhs.is_clean_data))
      return false;
    if (!(is_upgrade == rhs.is_upgrade))
      return false;
    return true;
  }
  bool operator != (const configuration_proposal_request &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const configuration_proposal_request & ) const;


};

void swap(configuration_proposal_request &a, configuration_proposal_request &b);

inline void unmarshall(::dsn::binary_reader& reader, __out_param configuration_proposal_request& val) {
  unmarshall(reader, val.config);
  unmarshall(reader, val.type);
  unmarshall(reader, val.node);
  ::dsn::unmarshall(reader, val.is_clean_data);
  ::dsn::unmarshall(reader, val.is_upgrade);
}

inline void marshall(::dsn::binary_writer& writer, const configuration_proposal_request& val, uint16_t pos = 0xffff) {
  marshall(writer, val.config, pos);
  marshall(writer, val.type, pos);
  marshall(writer, val.node, pos);
  ::dsn::marshall(writer, val.is_clean_data, pos);
  ::dsn::marshall(writer, val.is_upgrade, pos);
}


class configuration_query_by_node_request {
 public:

  configuration_query_by_node_request(const configuration_query_by_node_request&);
  configuration_query_by_node_request& operator=(const configuration_query_by_node_request&);
  configuration_query_by_node_request() {
  }

  virtual ~configuration_query_by_node_request() throw();
   ::dsn::end_point node;
  bool operator == (const configuration_query_by_node_request & rhs) const
  {
    if (!(node == rhs.node))
      return false;
    return true;
  }
  bool operator != (const configuration_query_by_node_request &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const configuration_query_by_node_request & ) const;


};

void swap(configuration_query_by_node_request &a, configuration_query_by_node_request &b);

inline void unmarshall(::dsn::binary_reader& reader, __out_param configuration_query_by_node_request& val) {
  unmarshall(reader, val.node);
}

inline void marshall(::dsn::binary_writer& writer, const configuration_query_by_node_request& val, uint16_t pos = 0xffff) {
  marshall(writer, val.node, pos);
}


class configuration_query_by_node_response {
 public:

  configuration_query_by_node_response(const configuration_query_by_node_response&);
  configuration_query_by_node_response& operator=(const configuration_query_by_node_response&);
  configuration_query_by_node_response() : err(0) {
  }

  virtual ~configuration_query_by_node_response() throw();
  int32_t err;
  std::vector<partition_configuration>  partitions;
  bool operator == (const configuration_query_by_node_response & rhs) const
  {
    if (!(err == rhs.err))
      return false;
    if (!(partitions == rhs.partitions))
      return false;
    return true;
  }
  bool operator != (const configuration_query_by_node_response &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const configuration_query_by_node_response & ) const;


};

void swap(configuration_query_by_node_response &a, configuration_query_by_node_response &b);

inline void unmarshall(::dsn::binary_reader& reader, __out_param configuration_query_by_node_response& val) {
  ::dsn::unmarshall(reader, val.err);
  unmarshall(reader, val.partitions);
}

inline void marshall(::dsn::binary_writer& writer, const configuration_query_by_node_response& val, uint16_t pos = 0xffff) {
  ::dsn::marshall(writer, val.err, pos);
  marshall(writer, val.partitions, pos);
}


class configuration_query_by_index_request {
 public:

  configuration_query_by_index_request(const configuration_query_by_index_request&);
  configuration_query_by_index_request& operator=(const configuration_query_by_index_request&);
  configuration_query_by_index_request() : app_name() {
  }

  virtual ~configuration_query_by_index_request() throw();
  std::string app_name;
  std::vector<int32_t>  partition_indices;
  bool operator == (const configuration_query_by_index_request & rhs) const
  {
    if (!(app_name == rhs.app_name))
      return false;
    if (!(partition_indices == rhs.partition_indices))
      return false;
    return true;
  }
  bool operator != (const configuration_query_by_index_request &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const configuration_query_by_index_request & ) const;


};

void swap(configuration_query_by_index_request &a, configuration_query_by_index_request &b);

inline void unmarshall(::dsn::binary_reader& reader, __out_param configuration_query_by_index_request& val) {
  ::dsn::unmarshall(reader, val.app_name);
  unmarshall(reader, val.partition_indices);
}

inline void marshall(::dsn::binary_writer& writer, const configuration_query_by_index_request& val, uint16_t pos = 0xffff) {
  ::dsn::marshall(writer, val.app_name, pos);
  marshall(writer, val.partition_indices, pos);
}


class configuration_query_by_index_response {
 public:

  configuration_query_by_index_response(const configuration_query_by_index_response&);
  configuration_query_by_index_response& operator=(const configuration_query_by_index_response&);
  configuration_query_by_index_response() : err(0) {
  }

  virtual ~configuration_query_by_index_response() throw();
  int32_t err;
  std::vector<partition_configuration>  partitions;
  bool operator == (const configuration_query_by_index_response & rhs) const
  {
    if (!(err == rhs.err))
      return false;
    if (!(partitions == rhs.partitions))
      return false;
    return true;
  }
  bool operator != (const configuration_query_by_index_response &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const configuration_query_by_index_response & ) const;


};

void swap(configuration_query_by_index_response &a, configuration_query_by_index_response &b);

inline void unmarshall(::dsn::binary_reader& reader, __out_param configuration_query_by_index_response& val) {
  ::dsn::unmarshall(reader, val.err);
  unmarshall(reader, val.partitions);
}

inline void marshall(::dsn::binary_writer& writer, const configuration_query_by_index_response& val, uint16_t pos = 0xffff) {
  ::dsn::marshall(writer, val.err, pos);
  marshall(writer, val.partitions, pos);
}


class query_replica_decree_request {
 public:

  query_replica_decree_request(const query_replica_decree_request&);
  query_replica_decree_request& operator=(const query_replica_decree_request&);
  query_replica_decree_request() {
  }

  virtual ~query_replica_decree_request() throw();
  global_partition_id gpid;
   ::dsn::end_point node;
  bool operator == (const query_replica_decree_request & rhs) const
  {
    if (!(gpid == rhs.gpid))
      return false;
    if (!(node == rhs.node))
      return false;
    return true;
  }
  bool operator != (const query_replica_decree_request &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const query_replica_decree_request & ) const;


};

void swap(query_replica_decree_request &a, query_replica_decree_request &b);

inline void unmarshall(::dsn::binary_reader& reader, __out_param query_replica_decree_request& val) {
  unmarshall(reader, val.gpid);
  unmarshall(reader, val.node);
}

inline void marshall(::dsn::binary_writer& writer, const query_replica_decree_request& val, uint16_t pos = 0xffff) {
  marshall(writer, val.gpid, pos);
  marshall(writer, val.node, pos);
}


class query_replica_decree_response {
 public:

  query_replica_decree_response(const query_replica_decree_response&);
  query_replica_decree_response& operator=(const query_replica_decree_response&);
  query_replica_decree_response() : err(0), last_decree(0) {
  }

  virtual ~query_replica_decree_response() throw();
  int32_t err;
  int64_t last_decree;
  bool operator == (const query_replica_decree_response & rhs) const
  {
    if (!(err == rhs.err))
      return false;
    if (!(last_decree == rhs.last_decree))
      return false;
    return true;
  }
  bool operator != (const query_replica_decree_response &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const query_replica_decree_response & ) const;


};

void swap(query_replica_decree_response &a, query_replica_decree_response &b);

inline void unmarshall(::dsn::binary_reader& reader, __out_param query_replica_decree_response& val) {
  ::dsn::unmarshall(reader, val.err);
  ::dsn::unmarshall(reader, val.last_decree);
}

inline void marshall(::dsn::binary_writer& writer, const query_replica_decree_response& val, uint16_t pos = 0xffff) {
  ::dsn::marshall(writer, val.err, pos);
  ::dsn::marshall(writer, val.last_decree, pos);
}

}} // namespace

#endif
